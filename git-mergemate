#! /usr/bin/python2

# Copyright 2012-2013 Michael Haggerty <mhagger@alum.mit.edu>
#
# This file is part of git-mergemate.
#
# git-mergemate is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.

r"""Tools to help handle git nightmare merges.

usage:
    %(prog)s diagram [--full] BRANCH1...BRANCH2 >diagram.ppm

        Determine which pairs of commits from the two branchs can be
        merged together without conflict.  Output the result as a
        PPM-formatted image, where successful merges are shown as
        green pixels and unsuccessful merges as red pixels.

    %(prog)s merge BRANCH

        Merge the commits from BRANCH into HEAD, one commit at a
        time. In other words, transform this:

            o---o---o---o          HEAD
                 \
                  A---B---C---D    BRANCH

        into this:

            o---o---o---o---A'--B'--C'--D'    HEAD
                 \         /   /   /   /
                  --------A---B---C---D       BRANCH

        This is like a rebase, except with the history of individual
        merges retained [1].

        If there is a merge conflict, stop in "conflicted" state (as
        usual with a git merge).  The user should resolve the
        conflict, commit, and then re-execute the %(prog)s command to
        continue.

    %(prog)s find-conflict BRANCH1..BRANCH2

        Use bisection to determine the earliest commit on BRANCH2 that
        causes a conflict when merged to BRANCH1.  Don't actually
        retain any merges.

    %(prog)s find-conflict BRANCH1...BRANCH2

        Use bisection to find a pair of earliest commits (one from
        each branch) that do not merge cleanly.  Don't actually retain
        any merges.

    %(prog)s reparent [PARENT...]

        Change the parents of the HEAD commit to the specified list.
        Write the name of the new commit object to stdout without
        actually pointing HEAD at it.

In all cases, only the --first-parent commits are considered for
merging, and git rerere is disabled.

[1] http://softwareswirl.blogspot.de/2009/04/truce-in-merge-vs-rebase-war.html

"""

import sys
import os
import subprocess
import argparse
from cStringIO import StringIO

# CalledProcessError, check_call, and check_output were not in the
# original Python 2.4 subprocess library, so implement it here if
# necessary (implementations are taken from the Python 2.7 library):
try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

try:
    from subprocess import check_call
except ImportError:
    def check_call(*popenargs, **kwargs):
        retcode = subprocess.call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return 0

try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd, output=output)
        return output


def call_silently(cmd):
    try:
        NULL = open('/dev/null', 'w')
    except IOError:
        NULL = subprocess.PIPE

    p = subprocess.Popen(
        cmd, stdout=NULL, stderr=subprocess.PIPE,
        )
    (out,err) = p.communicate()
    retcode = p.wait()
    if retcode:
        raise CalledProcessError(retcode, cmd, err)


class UncleanWorkTreeError(Exception):
    pass


def require_clean_work_tree(action):
    """Verify that the current tree is clean.

    The code is a Python translation of the git-sh-setup(1) function
    of the same name."""

    process = subprocess.Popen(
        ['git', 'rev-parse', '--verify', 'HEAD'],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        )
    _unused, err = process.communicate()
    retcode = process.poll()
    if retcode:
        raise UncleanWorkTreeError(err.rstrip())

    check_call(['git', 'update-index', '-q', '--ignore-submodules', '--refresh'])

    error = []
    try:
        check_call(['git', 'diff-files', '--quiet', '--ignore-submodules'])
    except CalledProcessError:
        error.append('Cannot %s: You have unstaged changes.' % (action,))

    try:
        check_call([
            'git', 'diff-index', '--cached', '--quiet',
            '--ignore-submodules', 'HEAD', '--',
            ])
    except CalledProcessError:
        if not error:
            error.append('Cannot %s: Your index contains uncommitted changes.' % (action,))
        else:
            error.append('Additionally, your index contains uncommitted changes.')

    if error:
        raise UncleanWorkTreeError('\n'.join(error))


def rev_parse(arg):
    return check_output(['git', 'rev-parse', '--verify', '--quiet', arg]).strip()


def rev_list(*args):
    return [
        l.strip()
        for l in check_output(['git', 'rev-list'] + list(args),).splitlines()
        ]


def get_type(arg):
    """Return the type of a git object ('commit', 'tree', 'blob', or 'tag')."""

    return check_output(['git', 'cat-file', '-t', arg]).strip()


def get_commit_sha1(arg):
    """Convert arg into a SHA1 and verify that it refers to a commit.

    If not, raise ValueError."""

    try:
        return rev_parse('%s^{commit}' % (arg,))
    except CalledProcessError:
        raise ValueError('%r does not refer to a valid git commit' % (arg,))


class TemporaryHead(object):
    """A context manager that records the current HEAD state then restores it.

    The message is used for the reflog."""

    def __enter__(self, message='mergemate: restoring'):
        self.message = message
        try:
            self.head_name = check_output(['git', 'symbolic-ref', '--quiet', 'HEAD']).strip()
            sys.stderr.write('head_name = %r\n' % (self.head_name,))
        except CalledProcessError:
            self.head_name = None
        self.orig_head = get_commit_sha1('HEAD')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.head_name:
            try:
                check_call([
                    'git', 'symbolic-ref',
                    '-m', self.message, 'HEAD',
                    self.head_name,
                    ])
            except Exception, e:
                sys.stderr.write(
                    'Could not restore HEAD to %r!:    %s\n'
                    % (self.head_name, e.message,)
                    )
            else:
                try:
                    check_call(['git', 'reset', '--hard', self.orig_head])
                except Exception, e:
                    sys.stderr.write(
                        'Could not restore HEAD to %r!:    %s\n'
                        % (self.orig_head, e.message,)
                        )
        return False


def reparent(commit, parent_sha1s):
    """Create a new commit object like commit, but with the specified parents.

    commit is the SHA1 of an existing commit and parent_sha1s is a
    list of SHA1s.  Create a new commit exactly like that one, except
    that it has the specified parent commits.  Return the SHA1 of the
    resulting commit object, which is already stored in the object
    database but not yet referenced by anything."""

    old_commit = check_output(['git', 'cat-file', 'commit', commit])
    separator = old_commit.index('\n\n')
    headers = old_commit[:separator + 1].splitlines(True)
    rest = old_commit[separator + 1:]

    new_commit = StringIO()
    for i in range(len(headers)):
        line = headers[i]
        if line.startswith('tree '):
            new_commit.write(line)
            for parent_sha1 in parent_sha1s:
                new_commit.write('parent %s\n' % (parent_sha1,))
        elif line.startswith('parent '):
            # Discard old parents:
            pass
        else:
            new_commit.write(line)

    new_commit.write(rest)

    process = subprocess.Popen(
        ['git', 'hash-object', '-t', 'commit', '-w', '--stdin'],
        stdin=subprocess.PIPE, stdout=subprocess.PIPE,
        )
    out, err = process.communicate(new_commit.getvalue())
    retcode = process.poll()
    if retcode:
        raise RuntimeError('Could not reparent commit %s' % (commit,))
    return out.strip()


def merge_possible(commit1, commit2):
    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', '--no-commit', commit2])
    except CalledProcessError:
        sys.stderr.write('FAIL\n')
        return False
    else:
        sys.stderr.write('SUCCESS\n')
        return True
    finally:
        call_silently(['git', 'merge', '--abort'])


def find_first_false(f, lo, hi):
    """Return the smallest i in lo <= i < hi for which f(i) returns False using bisection.

    If there is no such i, return hi.

    """

    # Loop invariant: f(i) returns True for i < lo; f(i) returns False
    # for i >= hi.

    while lo < hi:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid + 1
        else:
            hi = mid

    return lo


def find_first_failing_merge(commit1, commits2):
    def f(i):
        commit2 = commits2[i]
        sys.stderr.write('Testing %s + %s -> ' % (commit1, commit2))
        return merge_possible(commit1, commit2)

    return find_first_false(f, 0, len(commits2))


def examine_merges(commit1, branch2, commits2):
    failing2 = find_first_failing_merge(commit1, commits2)
    if failing2 == 0:
        sys.stderr.write(
            '\n'
            'On branch %s, all commits fail to merge with %s:\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2, commits2[failing2],)
            )
    elif failing2 == len(commits2):
        sys.stderr.write(
            '\n'
            'On branch %s, all commits can be merged successfully with %s:\n'
            '    (%d) %s OK\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],)
            )
    else:
        sys.stderr.write(
            '\n'
            'On branch %s, failure to merge with %s arises between\n'
            '    (%d) %s OK\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],
               failing2, commits2[failing2],)
            )
    return failing2


def symmetric_merge(branch1, branch2):
    commits1 = rev_list('--first-parent', '%s..%s' % (branch2, branch1))
    commits1.reverse()
    commits2 = rev_list('--first-parent', '%s..%s' % (branch1, branch2))
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    failing2 = examine_merges(commits1[-1], branch2, commits2)
    if failing2 != len(commits2):
        examine_merges(commits2[failing2], branch1, commits1)


def asymmetric_merge(branch1, branch2):
    commits2 = rev_list('--first-parent', '%s..%s' % (branch1, branch2))
    commits2.reverse()

    sys.stderr.write('%s commits to examine\n' % (len(commits2),))

    examine_merges(branch1, branch2, commits2)


class MergeResults(object):
    """A map {(i1, i2) : mergeable}."""

    UNKNOWN = 0x00
    RESULT = 0x01
    CONFLICT = 0x00
    SUCCESSFUL = 0x01
    SOURCE = 0x06
    TESTED = 0x02
    INFERRED = 0x04

    def __init__(self, commits1, commits2):
        self.commits1 = list(commits1)
        self.n1 = len(self.commits1)
        self.commits2 = list(commits2)
        self.n2 = len(self.commits2)
        self._data = [[MergeResults.UNKNOWN] * self.n2 for i1 in range(self.n1)]
        self.filename_index = 0

    def is_mergeable(self, i1, i2):
        """Check whether specified commits can be merged successfully."""

        commit1 = self.commits1[i1]
        commit2 = self.commits2[i2]
        sys.stderr.write('Testing [%d] %s + [%d] %s -> ' % (i1, commit1, i2, commit2))
        retval = merge_possible(commit1, commit2)
        if retval:
            self._data[i1][i2] = MergeResults.TESTED | MergeResults.SUCCESSFUL
        else:
            self._data[i1][i2] = MergeResults.TESTED | MergeResults.CONFLICT
        return retval

    def __getitem__(self, index):
        (i1, i2) = index
        return self._data[i1][i2]

    def _setitem_impl(self, index, value):
        (i1, i2) = index
        if isinstance(i1, slice):
            for i in range(*i1.indices(self.n1)):
                self._setitem_impl((i, i2), value)
        elif isinstance(i2, slice):
            for i in range(*i2.indices(self.n2)):
                self._setitem_impl((i1, i), value)
        else:
            oldvalue = self._data[i1][i2]
            if oldvalue == MergeResults.UNKNOWN:
                self._data[i1][i2] = value
            elif oldvalue & MergeResults.RESULT != value & MergeResults.RESULT:
                raise ValueError(
                    'Overwriting result[%d,%d] == 0x%02x with different value 0x%02x\n'
                    '    for merge %s + %s'
                    % (i1, i2, oldvalue, value, self.commits1[i1], self.commits2[i2])
                    )

    def __setitem__(self, index, value):
        value = int(bool(value)) | MergeResults.INFERRED
        self._setitem_impl(index, value)

    OUTPUT_CHARS = {
        UNKNOWN : '?',
        SUCCESSFUL | TESTED : '+',
        SUCCESSFUL | INFERRED : '.',
        CONFLICT | TESTED : 'X',
        CONFLICT | INFERRED : 'x',
        }

    def write(self, f):
        for i2 in range(self.n2):
            for i1 in range(self.n1):
                f.write(self.OUTPUT_CHARS[self._data[i1][i2]])
            f.write('\n')

    OUTPUT_COLORS = {
        UNKNOWN : (63, 63, 63),
        SUCCESSFUL | TESTED : (0, 255, 0),
        SUCCESSFUL | INFERRED : (0, 127, 0),
        CONFLICT | TESTED : (255, 0, 0),
        CONFLICT | INFERRED : (127, 0, 0),
        }

    def writeppm(self, f):
        f.write('P3\n')
        f.write('%d %d 255\n' % (self.n1, self.n2,))
        for i2 in range(self.n2):
            f.write('%d %d %d' % self.OUTPUT_COLORS[self._data[0][i2]])
            for i1 in range(1, self.n1):
                f.write(' %d %d %d' % self.OUTPUT_COLORS[self._data[i1][i2]])
            f.write('\n')


def fill_full(results):
    if not results.commits1 or not results.commits2:
        return
    for i1 in range(results.n1):
        for i2 in range(results.n2):
            results[i1, i2] = results.is_mergeable(i1, i2)


def fill_assuming_monotonic(results):
    if not results.commits1 or not results.commits2:
        return

    i1 = 0
    i2 = results.n2

    # Given that these diagrams typically have few blocks, check the
    # end of a range first to see if the whole range can be filled in,
    # and fall back to bisection otherwise.
    while True:
        # Find the width of the success rectangle at row (i2-1) and fill it in:
        if results.is_mergeable(results.n1 - 1, i2 - 1):
            newi1 = results.n1
        else:
            newi1 = find_first_false(
                lambda i: results.is_mergeable(i, i2 - 1),
                i1, results.n1 - 1,
                )
        results[i1:newi1,:i2] = True
        i1 = newi1

        if i1 == results.n1:
            return

        # Find the height of the conflict rectangle at column i1 and fill it in:
        if not results.is_mergeable(i1, 0):
            newi2 = 0
        else:
            newi2 = find_first_false(
                lambda i: results.is_mergeable(i1, i),
                1, i2,
                )
        results[i1:, newi2:i2] = False
        i2 = newi2

        if i2 == 0:
            return


def diagram_merge(branch1, branch2, full=False):
    commits1 = rev_list('--first-parent', '%s..%s' % (branch2, branch1))
    commits1.reverse()
    commits2 = rev_list('--first-parent', '%s..%s' % (branch1, branch2))
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    results = MergeResults(commits1, commits2)
    if full:
        fill_full(results)
    else:
        fill_assuming_monotonic(results)
    results.writeppm(sys.stdout)


class MergeFailedException(Exception):
    pass


def merge(commit):
    try:
        check_call(
            ['git', '-c', 'rerere.enabled=false', 'merge', '--no-edit', commit],
            )
    except CalledProcessError:
        raise MergeFailedException('Failed to merge commit %s' % (commit,))


def incremental_merge(branch):
    commits = rev_list('--first-parent', 'HEAD..%s' % (branch,))
    commits.reverse()

    sys.stderr.write('%s commits to merge\n' % (len(commits),))

    try:
        for (i, commit) in enumerate(commits):
            sys.stderr.write('Merging %s (%d/%d)...\n' % (commit, i + 1, len(commits)))
            merge(commit)
    except MergeFailedException:
        sys.stderr.write('\n')
        sys.stderr.write('Failed to merge the following commits:\n')
        check_call(
            ['git', 'log', 'HEAD..%s' % (commit,)],
            )
        sys.stderr.write('\n')
        sys.exit('Merge of commit %s failed; please resolve manually' % (commit,))


def main(args):
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        )
    subparsers = parser.add_subparsers(dest='subcommand', help='sub-command')

    parser_diagram = subparsers.add_parser(
        'diagram',
        help='compute diagram of conflicts using bisection',
        )
    parser_diagram.add_argument(
        '--full', action='store_true',
        help=(
            'compute diagram of conflicts by computing all possible merges '
            '(otherwise a much faster bisection-based algorithm is used)'
            ),
        )
    parser_diagram.add_argument('range', help='BRANCH1...BRANCH2')

    parser_merge = subparsers.add_parser(
        'merge',
        help='merge a branch into HEAD incrementally',
        )
    parser_merge.add_argument('range', help='BRANCH')

    parser_conflict = subparsers.add_parser(
        'find-conflict',
        help='find conflicting commits that block a merge',
        )
    parser_conflict.add_argument(
        'range', help='BRANCH1..BRANCH2 | BRANCH1...BRANCH2'
        )

    parser_reparent = subparsers.add_parser(
        'reparent',
        help='change the parents of the HEAD commit',
        )
    parser_reparent.add_argument(
        'parents', nargs='*', help='[PARENT...]',
        )

    options = parser.parse_args(args)

    try:
        require_clean_work_tree('proceed')
    except UncleanWorkTreeError, e:
        sys.exit(e.message)

    if options.subcommand == 'diagram':
        if '...' not in options.range:
            parser.error(
                'diagram subcommand requires an argument BRANCH1...BRANCH2'
                )
        with TemporaryHead():
            (branch1, branch2) = options.range.split('...')
            diagram_merge(branch1, branch2, full=options.full)
    elif options.subcommand == 'merge':
        branch = options.range
        incremental_merge(branch)
    elif options.subcommand == 'find-conflict':
        if '...' in options.range:
            (branch1, branch2) = options.range.split('...')
            with TemporaryHead():
                symmetric_merge(branch1, branch2)
        elif '..' in options.range:
            (branch1, branch2) = options.range.split('..')
            with TemporaryHead():
                asymmetric_merge(branch1, branch2)
        else:
            parser.error(
                'RANGE must be of the form '
                '"BRANCH1..BRANCH2" or "BRANCH1...BRANCH2"'
                )
    elif options.subcommand == 'reparent':
        try:
            commit_sha1 = get_commit_sha1('HEAD')
        except ValueError:
            sys.exit('HEAD is not a valid commit')

        try:
            parent_sha1s = map(get_commit_sha1, options.parents)
        except ValueError, e:
            sys.exit(e.message)

        sys.stdout.write('%s\n' % (reparent(commit_sha1, parent_sha1s),))
    else:
        parser.error('Unrecognized subcommand')


main(sys.argv[1:])

