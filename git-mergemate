#! /usr/bin/python2

r"""Tools for crazy git merges.

usage:
    %(prog)s BRANCH

        Merge the commits from BRANCH into HEAD, one commit at a time.
        If there is a merge conflict, stop in "conflicted" state (as
        usual with a git merge).  After resolving the conflict, commit
        and then re-execute the %(prog)s command to continue.  In
        other words, transform this:

            o---o---o---o          HEAD
                 \
                  A---B---C---D    BRANCH

        into this:

            o---o---o---o---A'--B'--C'--D'    HEAD
                 \         /   /   /   /
                  --------A---B---C---D       BRANCH

        This is like a rebase, except with the history of individual
        merges retained [1].

    %(prog)s BRANCH1..BRANCH2

        Use bisection to determine the latest commit on BRANCH2 that
        can be merged successfully into BRANCH1.  Don't actually
        retain any merges.

    %(prog)s BRANCH1...BRANCH2

        Use bisection to find one of the latest commit pairs (one from
        each branch) that do not merge cleanly.  Don't actually retain
        any merges.

In all cases, only the --first-parent commits are considered for
merging, and git rerere is disabled.

[1] http://softwareswirl.blogspot.de/2009/04/truce-in-merge-vs-rebase-war.html

"""

import sys
import os
import subprocess
import argparse

# CalledProcessError, check_call, and check_output were not in the
# original Python 2.4 subprocess library, so implement it here if
# necessary (implementations are taken from the Python 2.7 library):
try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

try:
    from subprocess import check_call
except ImportError:
    def check_call(*popenargs, **kwargs):
        retcode = subprocess.call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return 0

try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd, output=output)
        return output


def rev_list(args):
    return [
        l.strip()
        for l in check_output(
            ['git', 'rev-list', '--first-parent'] + args,
            ).splitlines()
        ]


def call_silently(cmd):
    NULL = open('/dev/null', 'w')
    p = subprocess.Popen(
        cmd, stdout=NULL, stderr=subprocess.PIPE,
        )
    (out,err) = p.communicate()
    retcode = p.wait()
    if retcode:
        raise CalledProcessError(retcode, cmd, err)


def merge_possible(commit1, commit2):
    sys.stderr.write('Testing %s + %s -> ' % (commit1, commit2))
    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', '--no-commit', commit2])
    except CalledProcessError:
        sys.stderr.write('FAIL\n')
        return False
    else:
        sys.stderr.write('SUCCESS\n')
        return True
    finally:
        call_silently(['git', 'merge', '--abort'])


def find_first_failing_merge(commit1, commits2):
    # commits prior to this one succeed:
    lo = 0

    # this commit and its successors fail:
    hi = len(commits2)

    while lo < hi:
        mid = (lo + hi) // 2
        if merge_possible(commit1, commits2[mid]):
            lo = mid + 1
        else:
            hi = mid

    return lo


def examine_merges(commit1, branch2, commits2):
    failing2 = find_first_failing_merge(commit1, commits2)
    if failing2 == 0:
        sys.stderr.write(
            '\n'
            'On branch %s, all commits fail to merge with %s:\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2, commits2[failing2],)
            )
    elif failing2 == len(commits2):
        sys.stderr.write(
            '\n'
            'On branch %s, all commits can be merged successfully with %s:\n'
            '    (%d) %s OK\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],)
            )
    else:
        sys.stderr.write(
            '\n'
            'On branch %s, failure to merge with %s arises between\n'
            '    (%d) %s OK\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],
               failing2, commits2[failing2],)
            )
    return failing2


def symmetric_merge(branch1, branch2):
    commits1 = rev_list(['%s..%s' % (branch2, branch1)])
    commits1.reverse()
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    failing2 = examine_merges(commits1[-1], branch2, commits2)
    if failing2 != len(commits2):
        failing1 = examine_merges(commits2[failing2], branch1, commits1)


def asymmetric_merge(branch1, branch2):
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s commits to examine\n' % (len(commits2),))

    failing2 = examine_merges(branch1, branch2, commits2)


class MergeResults(object):
    """A dictionary {(commit1, commit2) : mergeable}."""

    def __init__(self, commits1, commits2, assume_monotonic=True):
        self.commits1 = list(commits1)
        self.indexes1 = dict((commit, i) for (i, commit) in enumerate(self.commits1))
        self.commits2 = list(commits2)
        self.indexes2 = dict((commit, i) for (i, commit) in enumerate(self.commits2))
        self.results = [[None] * len(commits2) for commit1 in commits1]
        self.assume_monotonic = assume_monotonic

    def __getitem__(self, index):
        (commit1, commit2) = index
        i1 = self.indexes1[commit1]
        i2 = self.indexes2[commit2]
        return self.results[i1][i2]

    def __setitem__(self, index, value):
        (commit1, commit2) = index
        i1 = self.indexes1[commit1]
        i2 = self.indexes2[commit2]
        if self.assume_monotonic:
            if value:
                # All entries with i1' <= i1 and i2' <= i2 are mergeable:
                for i1p in reversed(range(i1 + 1)):
                    if self.results[i1p][i2] is not None:
                        break
                    for i2p in reversed(range(i2 + 1)):
                        if self.results[i1p][i2p] is not None:
                            break
                        self.results[i1p][i2p] = value
            else:
                # All entries with i1' >= i1 and i2' >= i2 are non-mergeable:
                for i1p in range(i1, len(self.commits1)):
                    if self.results[i1p][i2] is not None:
                        break
                    for i2p in range(i2, len(self.commits2)):
                        if self.results[i1p][i2p] is not None:
                            break
                        self.results[i1p][i2p] = value
        else:
            self.results[i1][i2] = value

    def fill(self, commits1, commits2):
        if not commits1 or not commits2:
            return
        if not self.assume_monotonic:
            for commit1 in commits1:
                for commit2 in commits2:
                    self[commit1,commit2] = merge_possible(commit1, commit2)
        elif len(commits2) < len(commits1):
            i2 = len(commits2) // 2
            commit2 = commits2[i2]
            i1 = find_first_failing_merge(commit2, commits1)
            if i1 < len(commits1):
                self[commits1[i1],commit2] = False
            if i1 - 1 >= 0:
                self[commits1[i1 - 1],commit2] = True
            self.write(sys.stderr)
            if i1 < len(commits1):
                self.fill(commits1[i1:], commits2[:i2])
            if i1 - 1 >= 0:
                self.fill(commits1[:i1], commits2[i2 + 1:])
        else:
            i1 = len(commits1) // 2
            commit1 = commits1[i1]
            i2 = find_first_failing_merge(commit1, commits2)
            if i2 < len(commits2):
                self[commit1,commits2[i2]] = False
            if i2 - 1 >= 0:
                self[commit1,commits2[i2 - 1]] = True
            self.write(sys.stderr)
            if i2 < len(commits2):
                self.fill(commits1[:i1], commits2[i2:])
            if i2 - 1 >= 0:
                self.fill(commits1[i1 + 1:], commits2[:i2])

    OUTPUT_CHARS = {True : '.', False : 'X', None : '?'}

    def write(self, f):
        for i2 in range(len(self.commits2)):
            for i1 in range(len(self.commits1)):
                f.write(self.OUTPUT_CHARS[self.results[i1][i2]])
            f.write('\n')


def graph_merge(branch1, branch2, full=False):
    commits1 = rev_list(['%s..%s' % (branch2, branch1)])
    commits1.reverse()
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    results = MergeResults(commits1, commits2, not full)
    results.fill(commits1, commits2)
    results.write(sys.stdout)


class MergeFailedException(Exception):
    pass


def merge(commit):
    try:
        check_call(
            ['git', '-c', 'rerere.enabled=false', 'merge', '--no-edit', commit],
            )
    except CalledProcessError:
        raise MergeFailedException('Failed to merge commit %s' % (commit,))


def incremental_merge(branch):
    commits = rev_list(['HEAD..%s' % (branch,)])
    commits.reverse()

    sys.stderr.write('%s commits to merge\n' % (len(commits),))

    try:
        for (i, commit) in enumerate(commits):
            sys.stderr.write('Merging %s (%d/%d)...\n' % (commit, i + 1, len(commits)))
            merge(commit)
    except MergeFailedException, e:
        sys.stderr.write('\n')
        sys.stderr.write('Failed to merge the following commits:\n')
        check_call(
            ['git', 'log', 'HEAD..%s' % (commit,)],
            )
        sys.stderr.write('\n')
        sys.exit('Merge of commit %s failed; please resolve manually' % (commit,))


def main(args):
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        )
    parser.add_argument(
        '--graph', action='store_true',
        help='Compute graph of conflicts using bisection',
        )
    parser.add_argument(
        '--graph-full', action='store_true',
        help='Compute graph of conflicts',
        )
    parser.add_argument('range', help='BRANCH | BRANCH1..BRANCH2 | BRANCH1...BRANCH2')
    options = parser.parse_args(args)

    if '...' in options.range:
        (branch1, branch2) = options.range.split('...')
        if options.graph_full:
            graph_merge(branch1, branch2, full=True)
        elif options.graph:
            graph_merge(branch1, branch2, full=False)
        else:
            symmetric_merge(branch1, branch2)
    elif '..' in options.range:
        (branch1, branch2) = options.range.split('..')
        asymmetric_merge(branch1, branch2)
    else:
        branch = options.range
        incremental_merge(branch)


main(sys.argv[1:])

