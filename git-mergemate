#! /usr/bin/python2

r"""Tools for crazy git merges.

usage:
    %(prog)s BRANCH

        Merge the commits from BRANCH into HEAD, one commit at a time.
        If there is a merge conflict, stop in "conflicted" state (as
        usual with a git merge).  After resolving the conflict, commit
        and then re-execute the %(prog)s command to continue.  In
        other words, transform this:

            o---o---o---o          HEAD
                 \
                  A---B---C---D    BRANCH

        into this:

            o---o---o---o---A'--B'--C'--D'    HEAD
                 \         /   /   /   /
                  --------A---B---C---D       BRANCH

        This is like a rebase, except with the history of individual
        merges retained [1].

    %(prog)s BRANCH1..BRANCH2

        Use bisection to determine the latest commit on BRANCH2 that
        can be merged successfully into BRANCH1.  Don't actually
        retain any merges.

    %(prog)s BRANCH1...BRANCH2

        Use bisection to find one of the latest commit pairs (one from
        each branch) that do not merge cleanly.  Don't actually retain
        any merges.

In all cases, only the --first-parent commits are considered for
merging, and git rerere is disabled.

[1] http://softwareswirl.blogspot.de/2009/04/truce-in-merge-vs-rebase-war.html

"""

import sys
import os
import subprocess
import argparse

# CalledProcessError, check_call, and check_output were not in the
# original Python 2.4 subprocess library, so implement it here if
# necessary (implementations are taken from the Python 2.7 library):
try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

try:
    from subprocess import check_call
except ImportError:
    def check_call(*popenargs, **kwargs):
        retcode = subprocess.call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return 0

try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd, output=output)
        return output


def rev_list(args):
    return [
        l.strip()
        for l in check_output(
            ['git', 'rev-list', '--first-parent'] + args,
            ).splitlines()
        ]


def call_silently(cmd):
    NULL = open('/dev/null', 'w')
    p = subprocess.Popen(
        cmd, stdout=NULL, stderr=subprocess.PIPE,
        )
    (out,err) = p.communicate()
    retcode = p.wait()
    if retcode:
        raise CalledProcessError(retcode, cmd, err)


def merge_possible(commit1, commit2):
    sys.stderr.write('Testing %s + %s -> ' % (commit1, commit2))
    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', '--no-commit', commit2])
    except CalledProcessError:
        sys.stderr.write('FAIL\n')
        return False
    else:
        sys.stderr.write('SUCCESS\n')
        return True
    finally:
        call_silently(['git', 'merge', '--abort'])


def find_first_failing_merge(commit1, commits2):
    if not commits2:
        return 0

    # commits prior to this one succeed:
    lo = 0

    # this commit and its successors fail:
    hi = len(commits2)

    # The most common case will be that either all commits succeed or
    # all fail, which is somewhat pessimal for a bisect algorithm.  So
    # optimize for that case a little bit:
    #
    # 1. First test the middle commit.  This establishes whether, if
    #    all commits have the same result, whether that result is
    #    succeed vs. fail.
    #
    # 2. If the middle commit succeeded, then test commit 0;
    #    otherwise, test commit n-1.  This might prove that all
    #    succeed or all fail, leading to an early exit.
    #
    # 3. Then proceed with a traditional bisect.

    class Done(Exception):
        def __init__(self, retval):
            self.retval = retval

    def bisect(lo, mid, hi):
        success = merge_possible(commit1, commits2[mid])
        if success:
            lo = mid + 1
        else:
            hi = mid
        if hi == lo:
            raise Done(lo)
        return (success, lo, hi)

    try:
        (success, lo, hi) = bisect(lo, (lo + hi) // 2, hi)
        if success:
            (success, lo, hi) = bisect(lo, hi - 1, hi)
        else:
            (success, lo, hi) = bisect(lo, 0, hi)
        while True:
            (success, lo, hi) = bisect(lo, (lo + hi) // 2, hi)
    except Done, e:
        return e.retval


def examine_merges(commit1, branch2, commits2):
    failing2 = find_first_failing_merge(commit1, commits2)
    if failing2 == 0:
        sys.stderr.write(
            '\n'
            'On branch %s, all commits fail to merge with %s:\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2, commits2[failing2],)
            )
    elif failing2 == len(commits2):
        sys.stderr.write(
            '\n'
            'On branch %s, all commits can be merged successfully with %s:\n'
            '    (%d) %s OK\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],)
            )
    else:
        sys.stderr.write(
            '\n'
            'On branch %s, failure to merge with %s arises between\n'
            '    (%d) %s OK\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],
               failing2, commits2[failing2],)
            )
    return failing2


def symmetric_merge(branch1, branch2):
    commits1 = rev_list(['%s..%s' % (branch2, branch1)])
    commits1.reverse()
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    failing2 = examine_merges(commits1[-1], branch2, commits2)
    if failing2 != len(commits2):
        examine_merges(commits2[failing2], branch1, commits1)


def asymmetric_merge(branch1, branch2):
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s commits to examine\n' % (len(commits2),))

    examine_merges(branch1, branch2, commits2)


class MergeResults(object):
    """A dictionary {(commit1, commit2) : mergeable}."""

    def __init__(self, commits1, commits2, progress=None):
        self.commits1 = list(commits1)
        self.indexes1 = dict((commit, i) for (i, commit) in enumerate(self.commits1))
        self.commits2 = list(commits2)
        self.indexes2 = dict((commit, i) for (i, commit) in enumerate(self.commits2))
        self.results = [[None] * len(commits2) for commit1 in commits1]
        self.progress = progress
        self.filename_index = 0

    def __getitem__(self, index):
        (commit1, commit2) = index
        return self.results[self.indexes1[commit1]][self.indexes2[commit2]]

    def __setitem__(self, index, value):
        (commit1, commit2) = index
        self.results[self.indexes1[commit1]][self.indexes2[commit2]] = value

    def get_filename(self):
        try:
            return os.path.join(
                self.progress, 'crazymerge-%04d.ppm' % (self.filename_index,)
                )
        finally:
            self.filename_index += 1

    def show_progress(self):
        if self.progress:
            self.writeppm(open(self.get_filename(), 'w'))

    OUTPUT_CHARS = {True : '.', False : 'X', None : '?'}

    def write(self, f):
        for i2 in range(len(self.commits2)):
            for i1 in range(len(self.commits1)):
                f.write(self.OUTPUT_CHARS[self.results[i1][i2]])
            f.write('\n')

    OUTPUT_COLORS = {True : (0, 255, 0), False : (255, 0, 0), None : (255, 255, 0)}

    def writeppm(self, f):
        f.write('P3\n')
        f.write('%d %d 255\n' % (len(self.commits1), len(self.commits2),))
        for i2 in range(len(self.commits2)):
            f.write('%d %d %d' % self.OUTPUT_COLORS[self.results[0][i2]])
            for i1 in range(1, len(self.commits1)):
                f.write(' %d %d %d' % self.OUTPUT_COLORS[self.results[i1][i2]])
            f.write('\n')


def fill_full(results, commits1, commits2):
    if not commits1 or not commits2:
        return
    for commit1 in commits1:
        for commit2 in commits2:
            results[commit1,commit2] = merge_possible(commit1, commit2)


def fill_block(results, commit1, commit2, value):
    i1 = results.indexes1[commit1]
    i2 = results.indexes2[commit2]
    if value:
        # All entries with i1' <= i1 and i2' <= i2 are mergeable:
        for i1p in reversed(range(i1 + 1)):
            if results.results[i1p][i2] is not None:
                break
            for i2p in reversed(range(i2 + 1)):
                if results.results[i1p][i2p] is not None:
                    break
                results.results[i1p][i2p] = value
    else:
        # All entries with i1' >= i1 and i2' >= i2 are non-mergeable:
        for i1p in range(i1, len(results.commits1)):
            if results.results[i1p][i2] is not None:
                break
            for i2p in range(i2, len(results.commits2)):
                if results.results[i1p][i2p] is not None:
                    break
                results.results[i1p][i2p] = value


def fill_assuming_monotonic(results, commits1, commits2):
    if not commits1 or not commits2:
        return
    if len(commits2) < len(commits1):
        i2 = len(commits2) // 2
        commit2 = commits2[i2]
        i1 = find_first_failing_merge(commit2, commits1)
        if i1 < len(commits1):
            fill_block(results, commits1[i1], commit2, False)
        if i1 - 1 >= 0:
            fill_block(results, commits1[i1 - 1], commit2, True)
        results.show_progress()
        if i1 < len(commits1):
            fill_assuming_monotonic(results, commits1[i1:], commits2[:i2])
        if i1 - 1 >= 0:
            fill_assuming_monotonic(results, commits1[:i1], commits2[i2 + 1:])
    else:
        i1 = len(commits1) // 2
        commit1 = commits1[i1]
        i2 = find_first_failing_merge(commit1, commits2)
        if i2 < len(commits2):
            fill_block(results, commit1, commits2[i2], False)
        if i2 - 1 >= 0:
            fill_block(results, commit1, commits2[i2 - 1], True)
        results.show_progress()
        if i2 < len(commits2):
            fill_assuming_monotonic(results, commits1[:i1], commits2[i2:])
        if i2 - 1 >= 0:
            fill_assuming_monotonic(results, commits1[i1 + 1:], commits2[:i2])


def diagram_merge(branch1, branch2, full=False, progress=None):
    commits1 = rev_list(['%s..%s' % (branch2, branch1)])
    commits1.reverse()
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    results = MergeResults(commits1, commits2, progress=progress)
    if full:
        fill_full(results, commits1, commits2)
    else:
        fill_assuming_monotonic(results, commits1, commits2)
    results.writeppm(sys.stdout)


class MergeFailedException(Exception):
    pass


def merge(commit):
    try:
        check_call(
            ['git', '-c', 'rerere.enabled=false', 'merge', '--no-edit', commit],
            )
    except CalledProcessError:
        raise MergeFailedException('Failed to merge commit %s' % (commit,))


def incremental_merge(branch):
    commits = rev_list(['HEAD..%s' % (branch,)])
    commits.reverse()

    sys.stderr.write('%s commits to merge\n' % (len(commits),))

    try:
        for (i, commit) in enumerate(commits):
            sys.stderr.write('Merging %s (%d/%d)...\n' % (commit, i + 1, len(commits)))
            merge(commit)
    except MergeFailedException, e:
        sys.stderr.write('\n')
        sys.stderr.write('Failed to merge the following commits:\n')
        check_call(
            ['git', 'log', 'HEAD..%s' % (commit,)],
            )
        sys.stderr.write('\n')
        sys.exit('Merge of commit %s failed; please resolve manually' % (commit,))


def main(args):
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        )
    parser.add_argument(
        '--diagram', action='store_true',
        help='Compute diagram of conflicts using bisection',
        )
    parser.add_argument(
        '--progress', action='store', default=None, metavar='DIR',
        help='Write images showing progress to specified directory',
        )
    parser.add_argument(
        '--diagram-full', action='store_true',
        help=(
            'Compute diagram of conflicts by computing all possible merges '
            '(slower than --diagram)'
            ),
        )
    parser.add_argument('range', help='BRANCH | BRANCH1..BRANCH2 | BRANCH1...BRANCH2')
    options = parser.parse_args(args)

    if '...' in options.range:
        (branch1, branch2) = options.range.split('...')
        if options.diagram_full:
            diagram_merge(branch1, branch2, full=True, progress=options.progress)
        elif options.diagram:
            diagram_merge(branch1, branch2, full=False, progress=options.progress)
        else:
            symmetric_merge(branch1, branch2)
    elif '..' in options.range:
        (branch1, branch2) = options.range.split('..')
        asymmetric_merge(branch1, branch2)
    else:
        branch = options.range
        incremental_merge(branch)


main(sys.argv[1:])

