#! /usr/bin/python2

r"""Tools for crazy git merges.

usage:
    %(prog)s BRANCH

        Merge the commits from BRANCH into HEAD, one commit at a time.
        If there is a merge conflict, stop in "conflicted" state (as
        usual with a git merge).  After resolving the conflict, commit
        and then re-execute the %(prog)s command to continue.  In
        other words, transform this:

            o---o---o---o          HEAD
                 \
                  A---B---C---D    BRANCH

        into this:

            o---o---o---o---A'--B'--C'--D'    HEAD
                 \         /   /   /   /
                  --------A---B---C---D       BRANCH

        This is like a rebase, except with the history of individual
        merges retained [1].

    %(prog)s BRANCH1..BRANCH2

        Use bisection to determine the latest commit on BRANCH2 that
        can be merged successfully into BRANCH1.  Don't actually
        retain any merges.

    %(prog)s BRANCH1...BRANCH2

        Use bisection to find one of the latest commit pairs (one from
        each branch) that do not merge cleanly.  Don't actually retain
        any merges.

In all cases, only the --first-parent commits are considered for
merging, and git rerere is disabled.

[1] http://softwareswirl.blogspot.de/2009/04/truce-in-merge-vs-rebase-war.html

"""

import sys
import os
import subprocess
import argparse

# CalledProcessError, check_call, and check_output were not in the
# original Python 2.4 subprocess library, so implement it here if
# necessary (implementations are taken from the Python 2.7 library):
try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

try:
    from subprocess import check_call
except ImportError:
    def check_call(*popenargs, **kwargs):
        retcode = subprocess.call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return 0

try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd, output=output)
        return output


def rev_list(args):
    return [
        l.strip()
        for l in check_output(
            ['git', 'rev-list', '--first-parent'] + args,
            ).splitlines()
        ]


def call_silently(cmd):
    NULL = open('/dev/null', 'w')
    p = subprocess.Popen(
        cmd, stdout=NULL, stderr=subprocess.PIPE,
        )
    (out,err) = p.communicate()
    retcode = p.wait()
    if retcode:
        raise CalledProcessError(retcode, cmd, err)


def merge_possible(commit1, commit2):
    sys.stderr.write('Testing %s + %s -> ' % (commit1, commit2))
    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', '--no-commit', commit2])
    except CalledProcessError:
        sys.stderr.write('FAIL\n')
        return False
    else:
        sys.stderr.write('SUCCESS\n')
        return True
    finally:
        call_silently(['git', 'merge', '--abort'])


def find_first_failing_merge(commit1, commits2):
    # commits prior to this one succeed:
    lo = 0

    # this commit and its successors fail:
    hi = len(commits2)

    while lo < hi:
        mid = (lo + hi) // 2
        if merge_possible(commit1, commits2[mid]):
            lo = mid + 1
        else:
            hi = mid

    return lo


def examine_merges(commit1, branch2, commits2):
    failing2 = find_first_failing_merge(commit1, commits2)
    if failing2 == 0:
        sys.stderr.write(
            '\n'
            'On branch %s, all commits fail to merge with %s:\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2, commits2[failing2],)
            )
    elif failing2 == len(commits2):
        sys.stderr.write(
            '\n'
            'On branch %s, all commits can be merged successfully with %s:\n'
            '    (%d) %s OK\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],)
            )
    else:
        sys.stderr.write(
            '\n'
            'On branch %s, failure to merge with %s arises between\n'
            '    (%d) %s OK\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],
               failing2, commits2[failing2],)
            )
    return failing2


def symmetric_merge(branch1, branch2):
    commits1 = rev_list(['%s..%s' % (branch2, branch1)])
    commits1.reverse()
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    failing2 = examine_merges(commits1[-1], branch2, commits2)
    if failing2 != len(commits2):
        failing1 = examine_merges(commits2[failing2], branch1, commits1)


def asymmetric_merge(branch1, branch2):
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s commits to examine\n' % (len(commits2),))

    failing2 = examine_merges(branch1, branch2, commits2)


def graph_merge(branch1, branch2, full=False):
    commits1 = rev_list(['%s..%s' % (branch2, branch1)])
    commits1.reverse()
    commits2 = rev_list(['%s..%s' % (branch1, branch2)])
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    results = [[None] * len(commits2) for commit1 in commits1]

    if full:
        for i1, commit1 in enumerate(commits1):
            for i2, commit2 in enumerate(commits2):
                results[i1][i2] = merge_possible(commit1, commit2)
    elif len(commits2) < len(commits1):
        for i2, commit2 in enumerate(commits2):
            i1 = find_first_failing_merge(commit2, commits1)
            for i in range(len(commits1)):
                results[i][i2] = i < i1
    else:
        for i1, commit1 in enumerate(commits1):
            i2 = find_first_failing_merge(commit1, commits2)
            for i in range(len(commits2)):
                results[i1][i] = i < i2

    OUTPUT_CHARS = {True : '.', False : 'X'}

    for i2 in range(len(commits2)):
        for i1 in range(len(commits1)):
            print OUTPUT_CHARS[results[i1][i2]]


class MergeFailedException(Exception):
    pass


def merge(commit):
    try:
        check_call(
            ['git', '-c', 'rerere.enabled=false', 'merge', '--no-edit', commit],
            )
    except CalledProcessError:
        raise MergeFailedException('Failed to merge commit %s' % (commit,))


def incremental_merge(branch):
    commits = rev_list(['HEAD..%s' % (branch,)])
    commits.reverse()

    sys.stderr.write('%s commits to merge\n' % (len(commits),))

    try:
        for (i, commit) in enumerate(commits):
            sys.stderr.write('Merging %s (%d/%d)...\n' % (commit, i + 1, len(commits)))
            merge(commit)
    except MergeFailedException, e:
        sys.stderr.write('\n')
        sys.stderr.write('Failed to merge the following commits:\n')
        check_call(
            ['git', 'log', 'HEAD..%s' % (commit,)],
            )
        sys.stderr.write('\n')
        sys.exit('Merge of commit %s failed; please resolve manually' % (commit,))


def main(args):
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        )
    parser.add_argument(
        '--graph', action='store_true',
        help='Compute graph of conflicts using bisection',
        )
    parser.add_argument(
        '--graph-full', action='store_true',
        help='Compute graph of conflicts',
        )
    parser.add_argument('range', help='BRANCH | BRANCH1..BRANCH2 | BRANCH1...BRANCH2')
    options = parser.parse_args(args)

    if '...' in options.range:
        (branch1, branch2) = options.range.split('...')
        if options.graph_full:
            graph_merge(branch1, branch2, full=True)
        elif options.graph:
            graph_merge(branch1, branch2, full=False)
        else:
            symmetric_merge(branch1, branch2)
    elif '..' in options.range:
        (branch1, branch2) = options.range.split('..')
        asymmetric_merge(branch1, branch2)
    else:
        branch = options.range
        incremental_merge(branch)


main(sys.argv[1:])

