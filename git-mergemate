#! /usr/bin/python2

r"""Tools to help handle git nightmare merges.

usage:
    %(prog)s --diagram [--full] [--progress=DIR] BRANCH1...BRANCH2 >diagram.ppm

        Determine which pairs of commits from the two branchs can be
        merged together without conflict.  Output the result as a
        PPM-formatted image, where successful merges are shown as
        green pixels and unsuccessful merges as red pixels.

    %(prog)s BRANCH

        Merge the commits from BRANCH into HEAD, one commit at a
        time. In other words, transform this:

            o---o---o---o          HEAD
                 \
                  A---B---C---D    BRANCH

        into this:

            o---o---o---o---A'--B'--C'--D'    HEAD
                 \         /   /   /   /
                  --------A---B---C---D       BRANCH

        This is like a rebase, except with the history of individual
        merges retained [1].

        If there is a merge conflict, stop in "conflicted" state (as
        usual with a git merge).  The user should resolve the
        conflict, commit, and then re-execute the %(prog)s command to
        continue.

    %(prog)s BRANCH1..BRANCH2

        Use bisection to determine the latest commit on BRANCH2 that
        can be merged successfully into BRANCH1.  Don't actually
        retain any merges.

    %(prog)s BRANCH1...BRANCH2

        Use bisection to find one of the latest commit pairs (one from
        each branch) that do not merge cleanly.  Don't actually retain
        any merges.

In all cases, only the --first-parent commits are considered for
merging, and git rerere is disabled.

[1] http://softwareswirl.blogspot.de/2009/04/truce-in-merge-vs-rebase-war.html

"""

import sys
import os
import subprocess
import argparse

# CalledProcessError, check_call, and check_output were not in the
# original Python 2.4 subprocess library, so implement it here if
# necessary (implementations are taken from the Python 2.7 library):
try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

try:
    from subprocess import check_call
except ImportError:
    def check_call(*popenargs, **kwargs):
        retcode = subprocess.call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return 0

try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd, output=output)
        return output


def rev_list(*args):
    return [
        l.strip()
        for l in check_output(['git', 'rev-list'] + list(args),).splitlines()
        ]


def call_silently(cmd):
    NULL = open('/dev/null', 'w')
    p = subprocess.Popen(
        cmd, stdout=NULL, stderr=subprocess.PIPE,
        )
    (out,err) = p.communicate()
    retcode = p.wait()
    if retcode:
        raise CalledProcessError(retcode, cmd, err)


def merge_possible(commit1, commit2):
    sys.stderr.write('Testing %s + %s -> ' % (commit1, commit2))
    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', '--no-commit', commit2])
    except CalledProcessError:
        sys.stderr.write('FAIL\n')
        return False
    else:
        sys.stderr.write('SUCCESS\n')
        return True
    finally:
        call_silently(['git', 'merge', '--abort'])


def find_first_false(f, n):
    """Return the smallest i in 0 <= i < n for which f(i) returns False using bisection.

    If there is no such i, return n.

    """

    # values prior to this one return True:
    lo = 0

    # this value and its successors return False:
    hi = n

    while lo < hi:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid + 1
        else:
            hi = mid

    return lo


def find_first_failing_merge(commit1, commits2):
    def f(i):
        return merge_possible(commit1, commits2[i])

    return find_first_false(f, len(commits2))


def examine_merges(commit1, branch2, commits2):
    failing2 = find_first_failing_merge(commit1, commits2)
    if failing2 == 0:
        sys.stderr.write(
            '\n'
            'On branch %s, all commits fail to merge with %s:\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2, commits2[failing2],)
            )
    elif failing2 == len(commits2):
        sys.stderr.write(
            '\n'
            'On branch %s, all commits can be merged successfully with %s:\n'
            '    (%d) %s OK\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],)
            )
    else:
        sys.stderr.write(
            '\n'
            'On branch %s, failure to merge with %s arises between\n'
            '    (%d) %s OK\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],
               failing2, commits2[failing2],)
            )
    return failing2


def symmetric_merge(branch1, branch2):
    commits1 = rev_list('--first-parent', '%s..%s' % (branch2, branch1))
    commits1.reverse()
    commits2 = rev_list('--first-parent', '%s..%s' % (branch1, branch2))
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    failing2 = examine_merges(commits1[-1], branch2, commits2)
    if failing2 != len(commits2):
        examine_merges(commits2[failing2], branch1, commits1)


def asymmetric_merge(branch1, branch2):
    commits2 = rev_list('--first-parent', '%s..%s' % (branch1, branch2))
    commits2.reverse()

    sys.stderr.write('%s commits to examine\n' % (len(commits2),))

    examine_merges(branch1, branch2, commits2)


class MergeResults(object):
    """A map {(i1, i2) : mergeable}."""

    def __init__(self, commits1, commits2, progress=None):
        self.commits1 = list(commits1)
        self.indexes1 = dict((commit, i) for (i, commit) in enumerate(self.commits1))
        self.commits2 = list(commits2)
        self.indexes2 = dict((commit, i) for (i, commit) in enumerate(self.commits2))
        self.results = [[None] * len(commits2) for commit1 in commits1]
        self.progress = progress
        self.filename_index = 0

    def is_mergeable(self, i1, i2):
        """Check whether specified commits can be merged successfully."""

        return merge_possible(self.commits1[i1], self.commits2[i2])

    def __getitem__(self, index):
        (i1, i2) = index
        return self.results[i1][i2]

    def __setitem__(self, index, value):
        (i1, i2) = index
        self.results[i1][i2] = value

    def get_filename(self):
        try:
            return os.path.join(
                self.progress, 'crazymerge-%04d.ppm' % (self.filename_index,)
                )
        finally:
            self.filename_index += 1

    def show_progress(self):
        if self.progress:
            self.writeppm(open(self.get_filename(), 'w'))

    OUTPUT_CHARS = {True : '.', False : 'X', None : '?'}

    def write(self, f):
        for i2 in range(len(self.commits2)):
            for i1 in range(len(self.commits1)):
                f.write(self.OUTPUT_CHARS[self.results[i1][i2]])
            f.write('\n')

    OUTPUT_COLORS = {True : (0, 255, 0), False : (255, 0, 0), None : (255, 255, 0)}

    def writeppm(self, f):
        f.write('P3\n')
        f.write('%d %d 255\n' % (len(self.commits1), len(self.commits2),))
        for i2 in range(len(self.commits2)):
            f.write('%d %d %d' % self.OUTPUT_COLORS[self.results[0][i2]])
            for i1 in range(1, len(self.commits1)):
                f.write(' %d %d %d' % self.OUTPUT_COLORS[self.results[i1][i2]])
            f.write('\n')


def fill_full(results):
    if not results.commits1 or not results.commits2:
        return
    for i1 in range(len(results.commits1)):
        for i2 in range(len(results.commits2)):
            results[i1, i2] = results.is_mergeable(i1, i2)


def fill_block(results, indexes1, indexes2, value):
    for i1 in indexes1:
        for i2 in indexes2:
            results[i1,i2] = value


def fill_assuming_monotonic(results):
    if not results.commits1 or not results.commits2:
        return

    i1 = 0
    i2 = len(results.commits2)

    # Given that these diagrams typically have few blocks, check the
    # end of a range first to see if the whole range can be filled in,
    # and fall back to bisection otherwise.
    while True:
        # Find the width of the success rectangle at row (i2-1) and fill it in:
        if results.is_mergeable(len(results.commits1) - 1, i2 - 1):
            newi1 = len(results.commits1)
        else:
            newi1 = find_first_failing_merge(results.commits2[i2 - 1], results.commits1[i1:-1]) + i1
        fill_block(results, range(i1, newi1), range(0, i2), True)
        i1 = newi1
        results.show_progress()

        if i1 == len(results.commits1):
            return

        # Find the height of the conflict rectangle at column i1 and fill it in:
        if not results.is_mergeable(i1, 0):
            newi2 = 0
        else:
            newi2 = find_first_failing_merge(results.commits1[i1], results.commits2[1:i2]) + 1
        fill_block(results, range(i1, len(results.commits1)), range(newi2, i2), False)
        i2 = newi2
        results.show_progress()

        if i2 == 0:
            return


def diagram_merge(branch1, branch2, full=False, progress=None):
    commits1 = rev_list('--first-parent', '%s..%s' % (branch2, branch1))
    commits1.reverse()
    commits2 = rev_list('--first-parent', '%s..%s' % (branch1, branch2))
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    results = MergeResults(commits1, commits2, progress=progress)
    if full:
        fill_full(results)
    else:
        fill_assuming_monotonic(results)
    results.writeppm(sys.stdout)


class MergeFailedException(Exception):
    pass


def merge(commit):
    try:
        check_call(
            ['git', '-c', 'rerere.enabled=false', 'merge', '--no-edit', commit],
            )
    except CalledProcessError:
        raise MergeFailedException('Failed to merge commit %s' % (commit,))


def incremental_merge(branch):
    commits = rev_list('--first-parent', 'HEAD..%s' % (branch,))
    commits.reverse()

    sys.stderr.write('%s commits to merge\n' % (len(commits),))

    try:
        for (i, commit) in enumerate(commits):
            sys.stderr.write('Merging %s (%d/%d)...\n' % (commit, i + 1, len(commits)))
            merge(commit)
    except MergeFailedException, e:
        sys.stderr.write('\n')
        sys.stderr.write('Failed to merge the following commits:\n')
        check_call(
            ['git', 'log', 'HEAD..%s' % (commit,)],
            )
        sys.stderr.write('\n')
        sys.exit('Merge of commit %s failed; please resolve manually' % (commit,))


def main(args):
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        )
    parser.add_argument(
        '--diagram', action='store_true',
        help='Compute diagram of conflicts using bisection',
        )
    parser.add_argument(
        '--full', action='store_true',
        help=(
            'Compute diagram of conflicts by computing all possible merges '
            '(otherwise a much faster bisection-based algorithm is used)'
            ),
        )
    parser.add_argument(
        '--progress', action='store', default=None, metavar='DIR',
        help='Write images showing progress to specified directory',
        )
    parser.add_argument('range', help='BRANCH | BRANCH1..BRANCH2 | BRANCH1...BRANCH2')
    options = parser.parse_args(args)

    if '...' in options.range:
        (branch1, branch2) = options.range.split('...')
        if options.diagram:
            diagram_merge(branch1, branch2, full=options.full, progress=options.progress)
        else:
            symmetric_merge(branch1, branch2)
    elif '..' in options.range:
        (branch1, branch2) = options.range.split('..')
        asymmetric_merge(branch1, branch2)
    else:
        branch = options.range
        incremental_merge(branch)


main(sys.argv[1:])

