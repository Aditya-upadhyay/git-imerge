#! /usr/bin/python2

# Copyright 2012-2013 Michael Haggerty <mhagger@alum.mit.edu>
#
# This file is part of git-imerge.
#
# git-imerge is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.

r"""Tools to help handle git nightmare merges.

usage:
    %(prog)s diagram [--full] BRANCH1...BRANCH2 >diagram.ppm

        Determine which pairs of commits from the two branchs can be
        merged together without conflict.  Output the result as a
        PPM-formatted image, where successful merges are shown as
        green pixels and unsuccessful merges as red pixels.

    %(prog)s reparent [PARENT...]

        Change the parents of the HEAD commit to the specified list.
        Write the name of the new commit object to stdout without
        actually pointing HEAD at it.

In all cases, only the --first-parent commits are considered for
merging, and git rerere is disabled.

[1] http://softwareswirl.blogspot.de/2009/04/truce-in-merge-vs-rebase-war.html

"""

import sys
import os
import re
import shutil
import subprocess
import itertools
import functools
import argparse
from cStringIO import StringIO
import json

# CalledProcessError, check_call, and check_output were not in the
# original Python 2.4 subprocess library, so implement it here if
# necessary (implementations are taken from the Python 2.7 library):
try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

try:
    from subprocess import check_call
except ImportError:
    def check_call(*popenargs, **kwargs):
        retcode = subprocess.call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return 0

try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd, output=output)
        return output


STATE_VERSION = (1, 0, 0)

ZEROS = '0' * 40


class Failure(Exception):
    """An exception that indicates a normal failure of the script.

    Failures are reported at top level via sys.exit(str(e)) rather
    than via a Python stack dump."""

    @classmethod
    def wrap(klass, f):
        """Wrap a function inside a try...except that catches this error.

        If the exception is thrown, call sys.exit().  This function
        can be used as a decorator."""

        @functools.wraps(f)
        def wrapper(*args, **kw):
            try:
                return f(*args, **kw)
            except klass, e:
                sys.exit(str(e))

        return wrapper

    pass


def call_silently(cmd):
    try:
        NULL = open('/dev/null', 'w')
    except IOError:
        NULL = subprocess.PIPE

    p = subprocess.Popen(
        cmd, stdout=NULL, stderr=subprocess.PIPE,
        )
    (out,err) = p.communicate()
    retcode = p.wait()
    if retcode:
        raise CalledProcessError(retcode, cmd, err)


class UncleanWorkTreeError(Failure):
    pass


def require_clean_work_tree(action):
    """Verify that the current tree is clean.

    The code is a Python translation of the git-sh-setup(1) function
    of the same name."""

    process = subprocess.Popen(
        ['git', 'rev-parse', '--verify', 'HEAD'],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        )
    _unused, err = process.communicate()
    retcode = process.poll()
    if retcode:
        raise UncleanWorkTreeError(err.rstrip())

    check_call(['git', 'update-index', '-q', '--ignore-submodules', '--refresh'])

    error = []
    try:
        check_call(['git', 'diff-files', '--quiet', '--ignore-submodules'])
    except CalledProcessError:
        error.append('Cannot %s: You have unstaged changes.' % (action,))

    try:
        check_call([
            'git', 'diff-index', '--cached', '--quiet',
            '--ignore-submodules', 'HEAD', '--',
            ])
    except CalledProcessError:
        if not error:
            error.append('Cannot %s: Your index contains uncommitted changes.' % (action,))
        else:
            error.append('Additionally, your index contains uncommitted changes.')

    if error:
        raise UncleanWorkTreeError('\n'.join(error))


def rev_parse(arg):
    return check_output(['git', 'rev-parse', '--verify', '--quiet', arg]).strip()


def rev_list(*args):
    return [
        l.strip()
        for l in check_output(['git', 'rev-list'] + list(args),).splitlines()
        ]


def get_type(arg):
    """Return the type of a git object ('commit', 'tree', 'blob', or 'tag')."""

    return check_output(['git', 'cat-file', '-t', arg]).strip()


def get_commit_sha1(arg):
    """Convert arg into a SHA1 and verify that it refers to a commit.

    If not, raise ValueError."""

    try:
        return rev_parse('%s^{commit}' % (arg,))
    except CalledProcessError:
        raise ValueError('%r does not refer to a valid git commit' % (arg,))


class TemporaryHead(object):
    """A context manager that records the current HEAD state then restores it.

    The message is used for the reflog."""

    def __enter__(self, message='imerge: restoring'):
        self.message = message
        try:
            self.head_name = check_output(['git', 'symbolic-ref', '--quiet', 'HEAD']).strip()
        except CalledProcessError:
            self.head_name = None
        self.orig_head = get_commit_sha1('HEAD')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.head_name:
            try:
                check_call([
                    'git', 'symbolic-ref',
                    '-m', self.message, 'HEAD',
                    self.head_name,
                    ])
            except Exception, e:
                raise Failure(
                    'Could not restore HEAD to %r!:    %s\n'
                    % (self.head_name, e.message,)
                    )
            else:
                try:
                    check_call(['git', 'reset', '--hard', self.orig_head])
                except Exception, e:
                    raise Failure(
                        'Could not restore HEAD to %r!:    %s\n'
                        % (self.orig_head, e.message,)
                        )
        return False


def reparent(commit, parent_sha1s):
    """Create a new commit object like commit, but with the specified parents.

    commit is the SHA1 of an existing commit and parent_sha1s is a
    list of SHA1s.  Create a new commit exactly like that one, except
    that it has the specified parent commits.  Return the SHA1 of the
    resulting commit object, which is already stored in the object
    database but is not yet referenced by anything."""

    old_commit = check_output(['git', 'cat-file', 'commit', commit])
    separator = old_commit.index('\n\n')
    headers = old_commit[:separator + 1].splitlines(True)
    rest = old_commit[separator + 1:]

    new_commit = StringIO()
    for i in range(len(headers)):
        line = headers[i]
        if line.startswith('tree '):
            new_commit.write(line)
            for parent_sha1 in parent_sha1s:
                new_commit.write('parent %s\n' % (parent_sha1,))
        elif line.startswith('parent '):
            # Discard old parents:
            pass
        else:
            new_commit.write(line)

    new_commit.write(rest)

    process = subprocess.Popen(
        ['git', 'hash-object', '-t', 'commit', '-w', '--stdin'],
        stdin=subprocess.PIPE, stdout=subprocess.PIPE,
        )
    out, err = process.communicate(new_commit.getvalue())
    retcode = process.poll()
    if retcode:
        raise Failure('Could not reparent commit %s' % (commit,))
    return out.strip()


class AutomaticMergeFailed(Exception):
    def __init__(self, commit1, commit2):
        Exception.__init__(
            self, 'Automatic merge of %s and %s failed' % (commit1, commit2,)
            )
        self.commit1, self.commit2 = commit1, commit2


def automerge(commit1, commit2):
    """Attempt an automatic merge of commit1 and commit2.

    Return the SHA1 of the resulting commit, or raise
    AutomaticMergeFailed on error.  This must be called with a clean
    worktree."""

    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', commit2])
    except CalledProcessError:
        call_silently(['git', 'merge', '--abort'])
        raise AutomaticMergeFailed(commit1, commit2)
    else:
        return get_commit_sha1('HEAD')


class MergeRecord(object):
    # Bits for the flags field:

    # There is a saved successful auto merge:
    SAVED_AUTO = 0x01

    # An auto merge (which may have been unsuccessful) has been done:
    NEW_AUTO = 0x02

    # There is a saved successful manual merge:
    SAVED_MANUAL = 0x04

    # A manual merge (which may have been unsuccessful) has been done:
    NEW_MANUAL = 0x08

    # Some useful bit combinations:
    SAVED = SAVED_AUTO | SAVED_MANUAL
    NEW = NEW_AUTO | NEW_MANUAL

    AUTO = SAVED_AUTO | NEW_AUTO
    MANUAL = SAVED_MANUAL | NEW_MANUAL

    def __init__(self, sha1=None, flags=0):
        # The currently believed correct merge, or None if it is
        # unknown or the best attempt was unsuccessful.
        self.sha1 = sha1

        # See bits above.
        self.flags = flags

    def record_merge(self, sha1, source):
        """Record a merge at this position.

        source must be SAVED_AUTO, SAVED_MANUAL, NEW_AUTO, or NEW_MANUAL."""

        if source == self.SAVED_AUTO:
            # SAVED_AUTO is recorded in any case, but only used if it
            # is the only info available.
            if self.flags & (self.MANUAL | self.NEW) == 0:
                self.sha1 = sha1
            self.flags |= source
        elif source == self.NEW_AUTO:
            # NEW_AUTO is silently ignored if any MANUAL value is
            # already recorded.
            if self.flags & self.MANUAL == 0:
                self.sha1 = sha1
                self.flags |= source
        elif source == self.SAVED_MANUAL:
            # SAVED_MANUAL is recorded in any case, but only used if
            # no NEW_MANUAL is available.
            if self.flags & self.NEW_MANUAL == 0:
                self.sha1 = sha1
            self.flags |= source
        elif source == self.NEW_MANUAL:
            # NEW_MANUAL is always used, and also causes NEW_AUTO to
            # be forgotten if present.
            self.sha1 = sha1
            self.flags = (self.flags | source) & ~self.NEW_AUTO
        else:
            raise ValueError('Undefined source: %s' % (source,))

    def is_known(self):
        return self.sha1 is not None


class UnexpectedMergeFailure(Exception):
    def __init__(self, msg, i1, i2):
        Exception.__init__(self, msg)
        self.i1, self.i2 = i1, i2


class Block(object):
    """A rectangular range of commits, indexed by (i1,i2).

    The commits block[0,1:] and block[1:,0] are always all known.
    block[0,0] may or may not be known; it is usually unneeded (except
    maybe implicitly).

    Members:

        len1, len2 -- the dimensions of the block.

    """

    def __init__(self, len1, len2):
        self.len1 = len1
        self.len2 = len2

    def _check_indexes(self, i1, i2):
        if not (0 <= i1 < self.len1):
            raise IndexError('first index (%s) is out of range 0:%d' % (i1, self.len1,))
        if not (0 <= i2 < self.len2):
            raise IndexError('second index (%s) is out of range 0:%d' % (i2, self.len2,))

    def _normalize_indexes(self, index):
        """Return a pair of non-negative integers (i1, i2)."""

        try:
            (i1, i2) = index
        except TypeError:
            raise IndexError('Block indexing requires exactly two indexes')

        if i1 < 0:
            i1 += self.len1
        if i2 < 0:
            i2 += self.len2

        self._check_indexes(i1, i2)
        return (i1, i2)

    def set_value(self, i1, i2, value):
        """Set the MergeRecord for integer indexes (i1, i2).

        i1 and i2 must be non-negative."""

        raise NotImplementedError()

    def __setitem__(self, index, value):
        """Return the MergeRecord for indexes (i1, i2).

        i1 and i2 must be integers, but they may be negative."""

        (i1, i2) = self._normalize_indexes(index)
        if i1 < 0:
            i1 += self.len1
        if i2 < 0:
            i2 += self.len2
        self.set_value(i1, i2, value)

    def get_value(self, i1, i2):
        """Return the MergeRecord for integer indexes (i1, i2).

        i1 and i2 must be non-negative."""

        raise NotImplementedError()

    def __getitem__(self, index):
        """Return the MergeRecord at (i1, i2) (requires two indexes).

        If i1 and i2 are integers but the merge is unknown, return
        None.  If either index is a slice, return a SubBlock."""

        try:
            (i1, i2) = index
        except TypeError:
            raise IndexError('Block indexing requires exactly two indexes')
        if isinstance(i1, slice) or isinstance(i2, slice):
            return SubBlock(self, i1, i2)
        else:
            return self.get_value(*self._normalize_indexes((i1, i2)))

    def __contains__(self, index):
        return self[index].is_known()

    def is_mergeable(self, i1, i2):
        """Determine whether (i1,i2) can be merged automatically.

        If we already have a merge record for (i1,i2), return True.
        Otherwise, attempt a merge (discarding the result)."""

        (i1, i2) = self._normalize_indexes((i1, i2))
        if (i1, i2) in self:
            return True
        else:
            try:
                automerge(self[i1, 0].sha1, self[0, i2].sha1)
                return True
            except AutomaticMergeFailed:
                return False

    def find_mergeable_blocks(self):
        """Return a list of blocks within this block that should be mergeable."""

        if self.len1 <= 1 or self.len2 <= 1:
            return []

        mergeable_blocks = []

        i1 = 1
        i2 = self.len2

        # Given that these diagrams typically have few blocks, check the
        # end of a range first to see if the whole range can be filled in,
        # and fall back to bisection otherwise.
        while True:
            # Find the width of the success rectangle at row (i2-1) and fill it in:
            if self.is_mergeable(self.len1 - 1, i2 - 1):
                newi1 = self.len1
            else:
                newi1 = find_first_false(
                    lambda i: self.is_mergeable(i, i2 - 1),
                    i1, self.len1 - 1,
                    )
            mergeable_blocks.append(self[:newi1,:i2])
            i1 = newi1

            if i1 == self.len1:
                break

            # Find the height of the conflict rectangle at column i1 and fill it in:
            if not self.is_mergeable(i1, 1):
                newi2 = 1
            else:
                newi2 = find_first_false(
                    lambda i: self.is_mergeable(i1, i),
                    2, i2,
                    )
            i2 = newi2

            if i2 == 1:
                break

        return mergeable_blocks

    def auto_outline(self):
        """Complete the outline of this Block.

        raise UnexpectedMergeFailure if automerging fails."""

        # Check that all of the merges go through before recording any
        # of them permanently.
        merges = []

        def do_merge(i1, commit1, i2, commit2):
            try:
                merge = automerge(commit1, commit2)
            except AutomaticMergeFailed, e:
                raise UnexpectedMergeFailure(str(e), i1, i2)
            merges.append((i1, i2, merge))
            return merge

        i2 = self.len2 - 1
        left = self[0, i2].sha1
        for i1 in range(1, self.len1 - 1):
            left = do_merge(i1, self[i1,0].sha1, i2, left)

        i1 = self.len1 - 1
        above = self[i1, 0].sha1
        for i2 in range(1, self.len2 - 1):
            above = do_merge(i1, above, i2, self[0,i2].sha1)

        i1, i2 = self.len1 - 1, self.len2 - 1
        do_merge(i1, above, i2, left)

        # Success!  Now we can record the results:
        for (i1, i2, merge) in merges:
            self[i1, i2].record_merge(merge, MergeRecord.NEW_AUTO)


class SubBlock(Block):
    @staticmethod
    def _convert_to_slice(i, len):
        """Return (start, len) for the specified index.

        i may be an integer or a slice with step equal to 1."""

        if isinstance(i, int):
            if i < 0:
                i += len
            i = slice(i, i + 1)
        elif isinstance(i, slice):
            if i.step is not None and i.step != 1:
                raise ValueError('Index has a non-zero step size')
        else:
            raise ValueError('Index cannot be converted to a slice')

        (start, stop, step) = i.indices(len)
        return (start, stop - start)

    def __init__(self, block, slice1, slice2):
        (start1, len1) = self._convert_to_slice(slice1, block.len1)
        (start2, len2) = self._convert_to_slice(slice2, block.len2)
        Block.__init__(self, len1, len2)
        if isinstance(block, SubBlock):
            # Peel away one level of indirection:
            self._block = block._block
            self._start1 = start1 + block._start1
            self._start2 = start2 + block._start2
        else:
            self._block = block
            self._start1 = start1
            self._start2 = start2

    def set_value(self, i1, i2, sha1, flags):
        self._check_indexes(i1, i2)
        self._block.set_value(i1 + self._start1, i2 + self._start2, sha1, flags)

    def get_value(self, i1, i2):
        self._check_indexes(i1, i2)
        return self._block.get_value(i1 + self._start1, i2 + self._start2)


class MergeState(Block):
    SOURCE_TABLE = {
        'auto' : MergeRecord.SAVED_AUTO,
        'manual' : MergeRecord.SAVED_MANUAL,
        }

    @staticmethod
    def read(name):
        merge_ref_re = re.compile(
            r"""
            ^
            refs\/imerge\/
            """ + re.escape(name) + r"""
            \/(?P<source>auto|manual)\/
            (?P<i1>0|[1-9][0-9]*)
            \-
            (?P<i2>0|[1-9][0-9]*)
            $
            """,
            re.VERBOSE,
            )

        state_ref_re = re.compile(
            r"""
            ^
            refs\/imerge\/
            """ + re.escape(name) + r"""
            \/state
            $
            """,
            re.VERBOSE,
            )

        state_string = None
        merges = {}
        unexpected = []
        for line in check_output([
                'git', 'for-each-ref', 'refs/imerge/%s' % (name,)
                ]).splitlines():
            (sha1, type, refname) = line.split()
            m = merge_ref_re.match(refname)
            if m:
                if type != 'commit':
                    raise Failure('Reference %r is not a commit!' % (refname,))
                i1, i2 = int(m.group('i1')), int(m.group('i2'))
                source = MergeState.SOURCE_TABLE[m.group('source')]
                merges[i1, i2].record_merge(sha1, source)
                continue

            m = state_ref_re.match(refname)
            if m:
                if type != 'blob':
                    raise Failure('Reference %r is not a blob!' % (refname,))
                state_string = check_output(['git', 'cat-file', 'blob', sha1])
                continue

            unexpected.append(refname)

        if unexpected:
            raise Failure(
                'Unexpected reference(s) found in "refs/imerge/%s" namespace:\n    %s\n'
                % (name, '\n    '.join(unexpected),)
                )

        # Find commits1 and commits2:
        commits1 = []
        for i1 in itertools.count(1):
            try:
                (source, sha1) = merges.pop((i1, 0))
                if source != 'manual':
                    raise Failure('Merge (%d,0) should be manual!' % (i1,))
                commits1.append(sha1)
            except KeyError:
                break

        commits2 = []
        for i2 in itertools.count(1):
            try:
                (source, sha1) = merges.pop((i2, 0))
                if source != 'manual':
                    raise Failure('Merge (0,%d) should be manual!' % (i2,))
                commits2.append(sha1)
            except KeyError:
                break

        state = MergeState(commits1, commits2, MergeRecord.SAVED_MANUAL)

        # Now write the rest of the merges to state:
        for ((i1, i2), (source, sha1)) in merges.iteritems():
            if i1 == 0 and i2 >= state.len2:
                raise Failure('Merge (0,%d) is missing!' % (state.len2,))
            if i1 >= state.len1 and i2 == 0:
                raise Failure('Merge (%d,0) is missing!' % (state.len1,))
            if i1 >= state.len1 or i2 >= state.len2:
                raise Failure(
                    'Merge (%d,%d) is out of range [0:%d,0:%d]'
                    % (i1, i2, state.len1, state.len2)
                    )
            state[i1, i2].record_merge(sha1, source)

    def __init__(self, commits1, commits2, source):
        Block.__init__(self, len(commits1) + 1, len(commits2) + 1)

        # A simulated 2D array.  Values are None or MergeRecord instances.
        self._data = [[None] * self.len2 for i1 in range(self.len1)]

        for (i1, commit) in enumerate(commits1, 1):
            self.get_value(i1, 0).record_merge(commit, source)
        for (i2, commit) in enumerate(commits2, 1):
            self.get_value(0, i2).record_merge(commit, source)

    def set_value(self, i1, i2, value):
        self._data[i1][i2] = value

    def get_value(self, i1, i2):
        value = self._data[i1][i2]
        # Missing values spring to life on first access:
        if value is None:
            value = MergeRecord()
            self._data[i1][i2] = value
        return value

    def __contains__(self, index):
        # Avoid creating new MergeRecord objects here.
        (i1, i2) = self._normalize_indexes(index)
        value = self._data[i1][i2]
        return (value is not None) and value.is_known()


def merge_possible(commit1, commit2):
    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', '--no-commit', commit2])
    except CalledProcessError:
        sys.stderr.write('FAIL\n')
        return False
    else:
        sys.stderr.write('SUCCESS\n')
        return True
    finally:
        call_silently(['git', 'merge', '--abort'])


def find_first_false(f, lo, hi):
    """Return the smallest i in lo <= i < hi for which f(i) returns False using bisection.

    If there is no such i, return hi.

    """

    # Loop invariant: f(i) returns True for i < lo; f(i) returns False
    # for i >= hi.

    while lo < hi:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid + 1
        else:
            hi = mid

    return lo


def find_first_failing_merge(commit1, commits2):
    def f(i):
        commit2 = commits2[i]
        sys.stderr.write('Testing %s + %s -> ' % (commit1, commit2))
        return merge_possible(commit1, commit2)

    return find_first_false(f, 0, len(commits2))


def examine_merges(commit1, branch2, commits2):
    failing2 = find_first_failing_merge(commit1, commits2)
    if failing2 == 0:
        sys.stderr.write(
            '\n'
            'On branch %s, all commits fail to merge with %s:\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2, commits2[failing2],)
            )
    elif failing2 == len(commits2):
        sys.stderr.write(
            '\n'
            'On branch %s, all commits can be merged successfully with %s:\n'
            '    (%d) %s OK\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],)
            )
    else:
        sys.stderr.write(
            '\n'
            'On branch %s, failure to merge with %s arises between\n'
            '    (%d) %s OK\n'
            '    (%d) %s FAIL\n'
            '\n'
            % (branch2, commit1,
               failing2 - 1, commits2[failing2 - 1],
               failing2, commits2[failing2],)
            )
    return failing2


class MergeResults(object):
    """A map {(i1, i2) : mergeable}."""

    UNKNOWN = 0x00
    RESULT = 0x01
    CONFLICT = 0x00
    SUCCESSFUL = 0x01
    SOURCE = 0x06
    TESTED = 0x02
    INFERRED = 0x04

    def __init__(self, commits1, commits2):
        self.commits1 = list(commits1)
        self.n1 = len(self.commits1)
        self.commits2 = list(commits2)
        self.n2 = len(self.commits2)
        self._data = [[MergeResults.UNKNOWN] * self.n2 for i1 in range(self.n1)]
        self.filename_index = 0

    def is_mergeable(self, i1, i2):
        """Check whether specified commits can be merged successfully."""

        commit1 = self.commits1[i1]
        commit2 = self.commits2[i2]
        sys.stderr.write('Testing [%d] %s + [%d] %s -> ' % (i1, commit1, i2, commit2))
        retval = merge_possible(commit1, commit2)
        if retval:
            self._data[i1][i2] = MergeResults.TESTED | MergeResults.SUCCESSFUL
        else:
            self._data[i1][i2] = MergeResults.TESTED | MergeResults.CONFLICT
        return retval

    def __getitem__(self, index):
        (i1, i2) = index
        return self._data[i1][i2]

    def _setitem_impl(self, index, value):
        (i1, i2) = index
        if isinstance(i1, slice):
            for i in range(*i1.indices(self.n1)):
                self._setitem_impl((i, i2), value)
        elif isinstance(i2, slice):
            for i in range(*i2.indices(self.n2)):
                self._setitem_impl((i1, i), value)
        else:
            oldvalue = self._data[i1][i2]
            if oldvalue == MergeResults.UNKNOWN:
                self._data[i1][i2] = value
            elif oldvalue & MergeResults.RESULT != value & MergeResults.RESULT:
                raise ValueError(
                    'Overwriting result[%d,%d] == 0x%02x with different value 0x%02x\n'
                    '    for merge %s + %s'
                    % (i1, i2, oldvalue, value, self.commits1[i1], self.commits2[i2])
                    )

    def __setitem__(self, index, value):
        value = int(bool(value)) | MergeResults.INFERRED
        self._setitem_impl(index, value)

    OUTPUT_CHARS = {
        UNKNOWN : '?',
        SUCCESSFUL | TESTED : '+',
        SUCCESSFUL | INFERRED : '.',
        CONFLICT | TESTED : 'X',
        CONFLICT | INFERRED : 'x',
        }

    def write(self, f):
        for i2 in range(self.n2):
            for i1 in range(self.n1):
                f.write(self.OUTPUT_CHARS[self._data[i1][i2]])
            f.write('\n')

    OUTPUT_COLORS = {
        UNKNOWN : (63, 63, 63),
        SUCCESSFUL | TESTED : (0, 255, 0),
        SUCCESSFUL | INFERRED : (0, 127, 0),
        CONFLICT | TESTED : (255, 0, 0),
        CONFLICT | INFERRED : (127, 0, 0),
        }

    def writeppm(self, f):
        f.write('P3\n')
        f.write('%d %d 255\n' % (self.n1, self.n2,))
        for i2 in range(self.n2):
            f.write('%d %d %d' % self.OUTPUT_COLORS[self._data[0][i2]])
            for i1 in range(1, self.n1):
                f.write(' %d %d %d' % self.OUTPUT_COLORS[self._data[i1][i2]])
            f.write('\n')


def fill_full(results):
    if not results.commits1 or not results.commits2:
        return
    for i1 in range(results.n1):
        for i2 in range(results.n2):
            results[i1, i2] = results.is_mergeable(i1, i2)


def fill_assuming_monotonic(results):
    if not results.commits1 or not results.commits2:
        return

    i1 = 0
    i2 = results.n2

    # Given that these diagrams typically have few blocks, check the
    # end of a range first to see if the whole range can be filled in,
    # and fall back to bisection otherwise.
    while True:
        # Find the width of the success rectangle at row (i2-1) and fill it in:
        if results.is_mergeable(results.n1 - 1, i2 - 1):
            newi1 = results.n1
        else:
            newi1 = find_first_false(
                lambda i: results.is_mergeable(i, i2 - 1),
                i1, results.n1 - 1,
                )
        results[i1:newi1,:i2] = True
        i1 = newi1

        if i1 == results.n1:
            return

        # Find the height of the conflict rectangle at column i1 and fill it in:
        if not results.is_mergeable(i1, 0):
            newi2 = 0
        else:
            newi2 = find_first_false(
                lambda i: results.is_mergeable(i1, i),
                1, i2,
                )
        results[i1:, newi2:i2] = False
        i2 = newi2

        if i2 == 0:
            return


def diagram_merge(branch1, branch2, full=False):
    commits1 = rev_list('--first-parent', '%s..%s' % (branch2, branch1))
    commits1.reverse()
    commits2 = rev_list('--first-parent', '%s..%s' % (branch1, branch2))
    commits2.reverse()

    sys.stderr.write('%s x %s commits to examine\n' % (len(commits1), len(commits2),))

    results = MergeResults(commits1, commits2)
    if full:
        fill_full(results)
    else:
        fill_assuming_monotonic(results)
    results.writeppm(sys.stdout)


class MergeFailedException(Exception):
    pass


class MergeState(object):
    """The state of an in-progress merge."""

    @staticmethod
    def get_state_filename(name):
        GIT_DIR = check_output(['git', 'rev-parse', '--git-dir']).rstrip()
        return os.path.join(GIT_DIR, 'imerge', name, 'state')

    @classmethod
    def iter_existing_names(klass):
        """Iterate over the names of existing MergeStates in this repo."""

        GIT_DIR = check_output(['git', 'rev-parse', '--git-dir']).rstrip()
        imerge_dir = os.path.join(GIT_DIR, 'imerge')
        if not os.path.isdir(imerge_dir):
            return
        names = os.listdir(imerge_dir)
        for name in names:
            state_filename = os.path.join(imerge_dir, name, 'state')
            if os.path.isfile(state_filename):
                yield name

    @classmethod
    def start(klass, name, goal, tip1, tip2):
        """Create and return a new MergeState object."""

        filename = klass.get_state_filename(name)
        if os.path.exists(filename):
            raise Failure('Name %r is already in use!' % (name,))
        if check_output(['git', 'for-each-ref', 'refs/imerge/%s' % (name,)]):
            raise Failure('Name %r is already in use!' % (name,))
        if '/' in name:
            raise Failure('Name %r must not include a slash character!' % (name,))
        try:
            call_silently(
                ['git', 'check-ref-format', 'refs/imerge/%s/%s-%s' % (name, ZEROS, ZEROS)]
                )
        except CalledProcessError:
            raise Failure('Name %r is not a valid refname component!' % (name,))

        commits1 = rev_list('--first-parent', '%s..%s' % (tip2, tip1))
        commits1.reverse()
        if not commits1:
            raise Failure(
                'There are no commits on %r that are not already in %r' % (tip1, tip2)
                )
        commits2 = rev_list('--first-parent', '%s..%s' % (tip1, tip2))
        commits2.reverse()
        if not commits2:
            raise Failure(
                'There are no commits on %r that are not already in %r' % (tip2, tip1)
                )

        merge = klass(name, goal, commits1, commits2)
        # Create refs pointing at the two tips to prevent their being
        # garbage-collected:
        merge.set_ref('tip1', commits1[-1], ZEROS, 'adding reference to tip1')
        merge.set_ref('tip2', commits2[-1], ZEROS, 'adding reference to tip2')
        merge.save()
        return merge

    @classmethod
    def set_default(klass, name):
        """Set the default merge to the specified one.

        name can be None to cause the default to be cleared."""

        if name is None:
            try:
                check_call(['git', 'config', '--unset', 'imerge.default'])
            except CalledProcessError, e:
                if e.returncode == 5:
                    # Value was not set
                    pass
                else:
                    raise
        else:
            check_call(['git', 'config', 'imerge.default', name])

    @classmethod
    def get_default(klass):
        """Get the name of the default merge, or None if none is currently set."""

        try:
            return check_output(['git', 'config', 'imerge.default']).rstrip()
        except CalledProcessError:
            return None

    @classmethod
    def load(klass, name):
        """Load an existing MergeState from disk."""

        f = open(klass.get_state_filename(name), 'rb')
        state = json.load(f)
        version = map(int, state['version'].split('.'))
        if version[0] != STATE_VERSION[0] or version > STATE_VERSION:
            raise Failure('Version of state is not compatible with this script version.')
        return klass(name, state['goal'], state['commits1'], state['commits2'])

    def __init__(self, name, goal, commits1, commits2):
        self.name = name
        self.goal = goal
        self.commits1 = commits1
        self.commits2 = commits2

    def save(self):
        filename = self.get_state_filename(self.name)
        dirname = os.path.dirname(filename)
        if not os.path.isdir(dirname):
            os.makedirs(dirname)
        f = open('%s.lock' % (filename,), 'wb')
        state = dict(
            version='.'.join(map(str, STATE_VERSION)),
            goal=self.goal,
            commits1=self.commits1,
            commits2=self.commits2,
            )
        json.dump(state, f, sort_keys=True, indent=4)
        f.close()
        os.rename('%s.lock' % (filename,), filename)

    def set_ref(self, refname, sha1, old_sha1, reason):
        check_call([
                'git', 'update-ref',
                '-m', 'imerge %r: %s' % (self.name, reason,),
                'refs/imerge/%s/%s' % (self.name, refname), sha1, old_sha1,
                ])

    @classmethod
    def iter_refs(klass, name):
        for line in check_output([
                'git', 'for-each-ref', 'refs/imerge/%s' % (name,)
                ]).splitlines():
            (sha1, type, refname) = line.split()
            yield (sha1, type, refname)

    @classmethod
    def remove(klass, name):
        filename = klass.get_state_filename(name)

        # If this merge is the default, unset the default:
        if klass.get_default() == name:
            klass.set_default(None)

        # Remove state directory:
        dirname = os.path.dirname(filename)
        if os.path.isdir(dirname):
            shutil.rmtree(dirname)
        else:
            sys.stderr.write('Warning: no directory %r\n' % (dirname,))

        # Remove 'imerge' directory if it is now empty:
        imerge_dirname = os.path.dirname(dirname)
        if not os.listdir(imerge_dirname):
            try:
                os.rmdir(imerge_dirname)
            except Exception, e:
                sys.stderr.write(
                    'Warning: Error removing directory %r: %s\n' % (imerge_dirname, e)
                    )

        # Remove any references associated with this merge:
        for (sha1, type, refname) in klass.iter_refs(name):
            try:
                check_call([
                        'git', 'update-ref',
                        '-m', 'imerge: remove merge %r' % (name,),
                        '-d', refname,
                        ])
            except CalledProcessError, e:
                sys.stderr.write(
                    'Warning: error removing reference %r: %s' % (refname, e)
                    )


@Failure.wrap
def main(args):
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        )
    subparsers = parser.add_subparsers(dest='subcommand', help='sub-command')

    parser_start = subparsers.add_parser(
        'start',
        help='start an incremental merge',
        )
    parser_start.add_argument(
        '--name', action='store', default='merge',
        help='name to use for this incremental merge',
        )
    parser_start.add_argument(
        '--goal',
        action='store', default='full',
        choices=['full', 'rebase-with-history', 'rebase', 'simple'],
        help='the goal of the incremental merge',
        )
    #parser_start.add_argument(
    #    '--conflicts', ...
    #    action='store', default='jump',
    #    choices=['pairwise', 'jump'],
    #    help='what sort of conflicts will be presented to the user',
    #    )
    parser_start.add_argument(
        '--first-parent', action='store_true', default=None,
        help=(
            'handle only the first parent commits '
            '(this option is currently required)'
            ),
        )
    parser_start.add_argument(
        'branch', action='store',
        help='the tip of the branch to be merged into HEAD',
        )

    parser_remove = subparsers.add_parser(
        'remove',
        help='irrevocably remove an incremental merge',
        )
    parser_remove.add_argument(
        '--name', action='store', default=None,
        help='name to use for this incremental merge',
        )

    parser_list = subparsers.add_parser(
        'list',
        help='list names of in-progress merges',
        )

    parser_diagram = subparsers.add_parser(
        'diagram',
        help='compute diagram of conflicts using bisection',
        )
    parser_diagram.add_argument(
        '--full', action='store_true',
        help=(
            'compute diagram of conflicts by computing all possible merges '
            '(otherwise a much faster bisection-based algorithm is used)'
            ),
        )
    parser_diagram.add_argument('range', help='BRANCH1...BRANCH2')

    parser_reparent = subparsers.add_parser(
        'reparent',
        help='change the parents of the HEAD commit',
        )
    parser_reparent.add_argument(
        'parents', nargs='*', help='[PARENT...]',
        )

    options = parser.parse_args(args)

    require_clean_work_tree('proceed')

    if options.subcommand == 'list':
        default_merge = MergeState.get_default()
        for name in MergeState.iter_existing_names():
            if name == default_merge:
                sys.stdout.write('* %s\n' % (name,))
            else:
                sys.stdout.write('  %s\n' % (name,))
    elif options.subcommand == 'start':
        if not options.first_parent:
            parser.error(
                'The --first-parent option is currently required for the "start" command'
                )
        MergeState.start(options.name, options.goal, 'HEAD', options.branch)
        MergeState.set_default(options.name)
    elif options.subcommand == 'remove':
        if options.name is None:
            parser.error('The "remove" command requires an option --name=NAME')
        state = MergeState.remove(options.name)
    elif options.subcommand == 'diagram':
        if '...' not in options.range:
            parser.error(
                'diagram subcommand requires an argument BRANCH1...BRANCH2'
                )
        with TemporaryHead():
            (branch1, branch2) = options.range.split('...')
            diagram_merge(branch1, branch2, full=options.full)
    elif options.subcommand == 'reparent':
        try:
            commit_sha1 = get_commit_sha1('HEAD')
        except ValueError:
            sys.exit('HEAD is not a valid commit')

        try:
            parent_sha1s = map(get_commit_sha1, options.parents)
        except ValueError, e:
            sys.exit(e.message)

        sys.stdout.write('%s\n' % (reparent(commit_sha1, parent_sha1s),))
    else:
        parser.error('Unrecognized subcommand')


main(sys.argv[1:])

