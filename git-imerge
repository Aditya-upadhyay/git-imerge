#! /usr/bin/python2

# Copyright 2012-2013 Michael Haggerty <mhagger@alum.mit.edu>
#
# This file is part of git-imerge.
#
# git-imerge is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.

r"""Tools to help handle git nightmare merges.

usage:
    %(prog)s diagram [--full] BRANCH1...BRANCH2 >diagram.ppm

        Determine which pairs of commits from the two branchs can be
        merged together without conflict.  Output the result as a
        PPM-formatted image, where successful merges are shown as
        green pixels and unsuccessful merges as red pixels.

    %(prog)s reparent [PARENT...]

        Change the parents of the HEAD commit to the specified list.
        Write the name of the new commit object to stdout without
        actually pointing HEAD at it.

In all cases, only the --first-parent commits are considered for
merging, and git rerere is disabled.

[1] http://softwareswirl.blogspot.de/2009/04/truce-in-merge-vs-rebase-war.html

"""

import sys
import os
import re
import shutil
import subprocess
import itertools
import functools
import argparse
from cStringIO import StringIO
import json

# CalledProcessError, check_call, and check_output were not in the
# original Python 2.4 subprocess library, so implement it here if
# necessary (implementations are taken from the Python 2.7 library):
try:
    from subprocess import CalledProcessError
except ImportError:
    class CalledProcessError(Exception):
        def __init__(self, returncode, cmd, output=None):
            self.returncode = returncode
            self.cmd = cmd
            self.output = output
        def __str__(self):
            return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)

try:
    from subprocess import check_call
except ImportError:
    def check_call(*popenargs, **kwargs):
        retcode = subprocess.call(*popenargs, **kwargs)
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return 0

try:
    from subprocess import check_output
except ImportError:
    def check_output(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd, output=output)
        return output


STATE_VERSION = (1, 0, 0)

ZEROS = '0' * 40

ALLOWED_GOALS = ['full', 'rebase-with-history', 'rebase', 'simple']
DEFAULT_GOAL = 'simple'


class Failure(Exception):
    """An exception that indicates a normal failure of the script.

    Failures are reported at top level via sys.exit(str(e)) rather
    than via a Python stack dump."""

    @classmethod
    def wrap(klass, f):
        """Wrap a function inside a try...except that catches this error.

        If the exception is thrown, call sys.exit().  This function
        can be used as a decorator."""

        @functools.wraps(f)
        def wrapper(*args, **kw):
            try:
                return f(*args, **kw)
            except klass, e:
                sys.exit(str(e))

        return wrapper

    pass


def iter_neighbors(iterable):
    """For an iterable (x0, x1, x2, ...) generate [(x0,x1), (x1,x2), ...]."""

    i = iter(iterable)

    try:
        last = i.next()
    except StopIteration:
        return

    for x in i:
        yield (last, x)
        last = x


def find_first_false(f, lo, hi):
    """Return the smallest i in lo <= i < hi for which f(i) returns False using bisection.

    If there is no such i, return hi.

    """

    # Loop invariant: f(i) returns True for i < lo; f(i) returns False
    # for i >= hi.

    while lo < hi:
        mid = (lo + hi) // 2
        if f(mid):
            lo = mid + 1
        else:
            hi = mid

    return lo


def call_silently(cmd):
    try:
        NULL = open('/dev/null', 'w')
    except IOError:
        NULL = subprocess.PIPE

    p = subprocess.Popen(
        cmd, stdout=NULL, stderr=subprocess.PIPE,
        )
    (out,err) = p.communicate()
    retcode = p.wait()
    if retcode:
        raise CalledProcessError(retcode, cmd, err)


class UncleanWorkTreeError(Failure):
    pass


def require_clean_work_tree(action):
    """Verify that the current tree is clean.

    The code is a Python translation of the git-sh-setup(1) function
    of the same name."""

    process = subprocess.Popen(
        ['git', 'rev-parse', '--verify', 'HEAD'],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        )
    _unused, err = process.communicate()
    retcode = process.poll()
    if retcode:
        raise UncleanWorkTreeError(err.rstrip())

    check_call(['git', 'update-index', '-q', '--ignore-submodules', '--refresh'])

    error = []
    try:
        check_call(['git', 'diff-files', '--quiet', '--ignore-submodules'])
    except CalledProcessError:
        error.append('Cannot %s: You have unstaged changes.' % (action,))

    try:
        check_call([
            'git', 'diff-index', '--cached', '--quiet',
            '--ignore-submodules', 'HEAD', '--',
            ])
    except CalledProcessError:
        if not error:
            error.append('Cannot %s: Your index contains uncommitted changes.' % (action,))
        else:
            error.append('Additionally, your index contains uncommitted changes.')

    if error:
        raise UncleanWorkTreeError('\n'.join(error))


def rev_parse(arg):
    return check_output(['git', 'rev-parse', '--verify', '--quiet', arg]).strip()


def rev_list(*args):
    return [
        l.strip()
        for l in check_output(['git', 'rev-list'] + list(args),).splitlines()
        ]


def get_type(arg):
    """Return the type of a git object ('commit', 'tree', 'blob', or 'tag')."""

    return check_output(['git', 'cat-file', '-t', arg]).strip()


def get_commit_sha1(arg):
    """Convert arg into a SHA1 and verify that it refers to a commit.

    If not, raise ValueError."""

    try:
        return rev_parse('%s^{commit}' % (arg,))
    except CalledProcessError:
        raise ValueError('%r does not refer to a valid git commit' % (arg,))


class TemporaryHead(object):
    """A context manager that records the current HEAD state then restores it.

    The message is used for the reflog."""

    def __enter__(self, message='imerge: restoring'):
        self.message = message
        try:
            self.head_name = check_output(['git', 'symbolic-ref', '--quiet', 'HEAD']).strip()
        except CalledProcessError:
            self.head_name = None
        self.orig_head = get_commit_sha1('HEAD')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.head_name:
            try:
                check_call([
                    'git', 'symbolic-ref',
                    '-m', self.message, 'HEAD',
                    self.head_name,
                    ])
            except Exception, e:
                raise Failure(
                    'Could not restore HEAD to %r!:    %s\n'
                    % (self.head_name, e.message,)
                    )
            else:
                try:
                    check_call(['git', 'reset', '--hard', self.orig_head])
                except Exception, e:
                    raise Failure(
                        'Could not restore HEAD to %r!:    %s\n'
                        % (self.orig_head, e.message,)
                        )
        return False


def reparent(commit, parent_sha1s):
    """Create a new commit object like commit, but with the specified parents.

    commit is the SHA1 of an existing commit and parent_sha1s is a
    list of SHA1s.  Create a new commit exactly like that one, except
    that it has the specified parent commits.  Return the SHA1 of the
    resulting commit object, which is already stored in the object
    database but is not yet referenced by anything."""

    old_commit = check_output(['git', 'cat-file', 'commit', commit])
    separator = old_commit.index('\n\n')
    headers = old_commit[:separator + 1].splitlines(True)
    rest = old_commit[separator + 1:]

    new_commit = StringIO()
    for i in range(len(headers)):
        line = headers[i]
        if line.startswith('tree '):
            new_commit.write(line)
            for parent_sha1 in parent_sha1s:
                new_commit.write('parent %s\n' % (parent_sha1,))
        elif line.startswith('parent '):
            # Discard old parents:
            pass
        else:
            new_commit.write(line)

    new_commit.write(rest)

    process = subprocess.Popen(
        ['git', 'hash-object', '-t', 'commit', '-w', '--stdin'],
        stdin=subprocess.PIPE, stdout=subprocess.PIPE,
        )
    out, err = process.communicate(new_commit.getvalue())
    retcode = process.poll()
    if retcode:
        raise Failure('Could not reparent commit %s' % (commit,))
    return out.strip()


class AutomaticMergeFailed(Exception):
    def __init__(self, commit1, commit2):
        Exception.__init__(
            self, 'Automatic merge of %s and %s failed' % (commit1, commit2,)
            )
        self.commit1, self.commit2 = commit1, commit2


def automerge(commit1, commit2):
    """Attempt an automatic merge of commit1 and commit2.

    Return the SHA1 of the resulting commit, or raise
    AutomaticMergeFailed on error.  This must be called with a clean
    worktree."""

    call_silently(['git', 'checkout', '-f', commit1])
    try:
        call_silently(['git', '-c', 'rerere.enabled=false', 'merge', commit2])
    except CalledProcessError:
        call_silently(['git', 'merge', '--abort'])
        raise AutomaticMergeFailed(commit1, commit2)
    else:
        return get_commit_sha1('HEAD')


class MergeRecord(object):
    # Bits for the flags field:

    # There is a saved successful auto merge:
    SAVED_AUTO = 0x01

    # An auto merge (which may have been unsuccessful) has been done:
    NEW_AUTO = 0x02

    # There is a saved successful manual merge:
    SAVED_MANUAL = 0x04

    # A manual merge (which may have been unsuccessful) has been done:
    NEW_MANUAL = 0x08

    # Some useful bit combinations:
    SAVED = SAVED_AUTO | SAVED_MANUAL
    NEW = NEW_AUTO | NEW_MANUAL

    AUTO = SAVED_AUTO | NEW_AUTO
    MANUAL = SAVED_MANUAL | NEW_MANUAL

    ALLOWED_INITIAL_FLAGS = [
        SAVED_AUTO,
        SAVED_MANUAL,
        NEW_AUTO,
        NEW_MANUAL,
        ]

    def __init__(self, sha1=None, flags=0):
        # The currently believed correct merge, or None if it is
        # unknown or the best attempt was unsuccessful.
        self.sha1 = sha1

        if self.sha1 is None:
            if flags != 0:
                raise ValueError('Initial flags (%s) for sha1=None should be 0' % (flags,))
        elif flags not in self.ALLOWED_INITIAL_FLAGS:
            raise ValueError('Initial flags (%s) is invalid' % (flags,))

        # See bits above.
        self.flags = flags

    def record_merge(self, sha1, source):
        """Record a merge at this position.

        source must be SAVED_AUTO, SAVED_MANUAL, NEW_AUTO, or NEW_MANUAL."""

        if source == self.SAVED_AUTO:
            # SAVED_AUTO is recorded in any case, but only used if it
            # is the only info available.
            if self.flags & (self.MANUAL | self.NEW) == 0:
                self.sha1 = sha1
            self.flags |= source
        elif source == self.NEW_AUTO:
            # NEW_AUTO is silently ignored if any MANUAL value is
            # already recorded.
            if self.flags & self.MANUAL == 0:
                self.sha1 = sha1
                self.flags |= source
        elif source == self.SAVED_MANUAL:
            # SAVED_MANUAL is recorded in any case, but only used if
            # no NEW_MANUAL is available.
            if self.flags & self.NEW_MANUAL == 0:
                self.sha1 = sha1
            self.flags |= source
        elif source == self.NEW_MANUAL:
            # NEW_MANUAL is always used, and also causes NEW_AUTO to
            # be forgotten if present.
            self.sha1 = sha1
            self.flags = (self.flags | source) & ~self.NEW_AUTO
        else:
            raise ValueError('Undefined source: %s' % (source,))

    def is_known(self):
        return self.sha1 is not None

    def save(self, name, i1, i2):
        """If this record has changed, save it."""

        def set_ref(source):
            check_call([
                    'git', 'update-ref',
                    '-m', 'imerge %r: Record %s merge' % (name, source,),
                    'refs/imerge/%s/%s/%d-%d' % (name, source, i1, i2),
                    self.sha1,
                    ])

        def clear_ref(source):
            check_call([
                    'git', 'update-ref',
                    '-d', 'imerge %r: Remove obsolete %s merge' % (name, source,),
                    'refs/imerge/%s/%s/%d-%d' % (name, source, i1, i2),
                    ])

        if self.flags & self.MANUAL:
            if self.flags & self.AUTO:
                # Any MANUAL obsoletes any AUTO:
                if self.flags & self.SAVED_AUTO:
                    clear_ref('auto')

                self.flags &= ~self.AUTO

            if self.flags & self.NEW_MANUAL:
                # Convert NEW_MANUAL to SAVED_MANUAL.
                if self.sha1:
                    set_ref('manual')
                    self.flags |= self.SAVED_MANUAL
                elif self.flags & self.SAVED_MANUAL:
                    # Delete any existing SAVED_MANUAL:
                    clear_ref('manual')
                    self.flags &= ~self.SAVED_MANUAL
                self.flags &= ~self.NEW_MANUAL

        elif self.flags & self.NEW_AUTO:
            # Convert NEW_AUTO to SAVED_AUTO.
            if self.sha1:
                set_ref('auto')
                self.flags |= self.SAVED_AUTO
            elif self.flags & self.SAVED_AUTO:
                # Delete any existing SAVED_AUTO:
                clear_ref('auto')
                self.flags &= ~self.SAVED_AUTO
            self.flags &= ~self.NEW_AUTO


class UnexpectedMergeFailure(Exception):
    def __init__(self, msg, i1, i2):
        Exception.__init__(self, msg)
        self.i1, self.i2 = i1, i2


class MergeFrontier(object):
    """Represents the merge frontier within a Block.

    A MergeFrontier is represented by a list of SubBlocks, each of
    which is thought to be completely mergeable.  The list is kept in
    normalized form:

    * Only non-empty blocks are retained

    * Blocks are sorted from bottom left to upper right

    * No redundant blocks

    """

    @staticmethod
    def map_known_frontier(block):
        """Return the MergeFrontier describing existing successful merges in block.

        The return value only includes the part that is fully outlined
        and whose outline consists of rectangles reaching back to
        (0,0)."""

        # FIXME: This algorithm can take combinatorial time, for
        # example if there is a big block of merges that is a dead
        # end:
        #
        #     +++++++
        #     +?+++++
        #     +?+++++
        #     +?+++++
        #     +?*++++
        #
        # The problem is that the algorithm will explore all of the
        # ways of getting to commit *, and the number of paths grows
        # like a binomial coefficient.  The solution would be to
        # remember dead-ends and reject any curves that visit a point
        # to the right of a dead-end.
        #
        # For now we don't intend to allow a situation like this to be
        # created, so we ignore the problem.

        # A list (i1, i2, down) of points in the path so far.  down is
        # True iff the attempted step following this one was
        # downwards.
        path = []

        def create_frontier(path):
            blocks = []
            for ((i1old, i2old, downold), (i1new, i2new, downnew)) in iter_neighbors(path):
                if downold == True and downnew == False:
                    blocks.append(block[:i1new + 1, :i2new + 1])
            return MergeFrontier(block, blocks)

        # Loop invariants:
        #
        # * path is a valid path
        #
        # * (i1, i2) is in block but it not yet added to path
        #
        # * down is True if a step downwards from (i1, i2) has not yet
        #   been attempted
        (i1, i2) = (block.len1 - 1, 0)
        down = True
        while True:
            if down:
                if i2 == block.len2 - 1:
                    # Hit edge of block; can't move down:
                    down = False
                elif (i1, i2 + 1) in block:
                    # Can move down
                    path.append((i1, i2, True))
                    i2 += 1
                else:
                    # Can't move down.
                    down = False
            else:
                if i1 == 0:
                    # Success!
                    path.append((i1, i2, False))
                    return create_frontier(path)
                elif (i1 - 1, i2) in block:
                    # Can move left
                    path.append((i1, i2, False))
                    down = True
                    i1 -= 1
                else:
                    # There's no way to go forward; backtrack until we
                    # find a place where we can still try going left:
                    while True:
                        try:
                            (i1, i2, down) = path.pop()
                        except IndexError:
                            # This shouldn't happen because, in the
                            # worst case, there is a valid path across
                            # the top edge of the merge diagram.
                            raise RuntimeError('Block is improperly formed!')
                        if down:
                            down = False
                            break

    @staticmethod
    def compute_by_bisection(block):
        """Return a MergeFrontier instance for block."""

        if block.len1 <= 1 or block.len2 <= 1:
            return MergeFrontier(block, [])

        blocks = []

        i1 = 1
        i2 = block.len2

        # Given that these diagrams typically have few blocks, check the
        # end of a range first to see if the whole range can be filled in,
        # and fall back to bisection otherwise.
        while True:
            # Find the width of the success rectangle at row (i2-1) and fill it in:
            if block.is_mergeable(block.len1 - 1, i2 - 1):
                newi1 = block.len1
            else:
                newi1 = find_first_false(
                    lambda i: block.is_mergeable(i, i2 - 1),
                    i1, block.len1 - 1,
                    )
            blocks.append(block[:newi1,:i2])
            i1 = newi1

            if i1 == block.len1:
                break

            # Find the height of the conflict rectangle at column i1 and fill it in:
            if not block.is_mergeable(i1, 1):
                newi2 = 1
            else:
                newi2 = find_first_false(
                    lambda i: block.is_mergeable(i1, i),
                    2, i2,
                    )
            i2 = newi2

            if i2 == 1:
                break

        return MergeFrontier(block, blocks)

    def __init__(self, block, blocks=None):
        self.block = block
        blocks = list(self._iter_non_empty_blocks(blocks or []))
        blocks.sort(key=lambda block: block.len1)
        self.blocks = list(self._iter_non_redundant_blocks(blocks))

    def __iter__(self):
        """Iterate over blocks from bottom left to upper right."""

        return iter(self.blocks)

    def __nonzero__(self):
        """Return True iff this frontier has no completed parts."""

        return bool(self.blocks)

    @staticmethod
    def _iter_non_empty_blocks(blocks):
        for block in blocks:
            if block.len1 > 1 and block.len2 > 1:
                yield block

    @staticmethod
    def _iter_non_redundant_blocks(blocks):
        def contains(block1, block2):
            """Return true if block1 contains block2."""

            return block1.len1 >= block2.len1 and block1.len2 >= block2.len2

        i = iter(blocks)
        try:
            last = i.next()
        except StopIteration:
            return

        for block in i:
            if contains(last, block):
                pass
            elif contains(block, last):
                last = block
            else:
                yield last
                last = block

        yield last

    def remove_failure(self, i1, i2):
        """Refine the merge frontier given that the specified merge fails."""

        shrunk_block = False
        for (i, block) in enumerate(self.blocks):
            if i1 < block.len1 and i2 < block.len2:
                self.blocks[i] = block[:i1, :i2]
                shrunk_block = True

        if shrunk_block:
            self.blocks = list(self._iter_non_redundant_blocks(self.blocks))

    def partition(self, block):
        """Return two MergeFrontier instances partitioned by block.

        Return (frontier1, frontier2), where each frontier is limited
        to each side of the argument.

        block must be contained in this MergeFrontier and already be
        outlined."""

        # Remember that the new blocks have to include the outlined
        # edge of the partitioning block to satisfy the invariant that
        # the left and upper edge of a block has to be known.

        left = []
        right = []
        for b in self.blocks:
            if b.len1 == block.len1 and b.len2 == block.len2:
                # That's the block we're partitioning on; just skip it.
                pass
            elif b.len1 < block.len1 and b.len2 > block.len2:
                left.append(b[:, block.len2 - 1:])
            elif b.len1 > block.len1 and b.len2 < block.len2:
                right.append(b[block.len1 - 1:, :])
            else:
                raise ValueError(
                    'MergeFrontier partitioned with inappropriate block'
                    )
        return (
            MergeFrontier(self.block[:block.len1, block.len2 - 1:], left),
            MergeFrontier(self.block[block.len1 - 1:, :block.len2], right),
            )


class Block(object):
    """A rectangular range of commits, indexed by (i1,i2).

    The commits block[0,1:] and block[1:,0] are always all known.
    block[0,0] may or may not be known; it is usually unneeded (except
    maybe implicitly).

    Members:

        len1, len2 -- the dimensions of the block.

    """

    def __init__(self, len1, len2):
        self.len1 = len1
        self.len2 = len2

    def _check_indexes(self, i1, i2):
        if not (0 <= i1 < self.len1):
            raise IndexError('first index (%s) is out of range 0:%d' % (i1, self.len1,))
        if not (0 <= i2 < self.len2):
            raise IndexError('second index (%s) is out of range 0:%d' % (i2, self.len2,))

    def _normalize_indexes(self, index):
        """Return a pair of non-negative integers (i1, i2)."""

        try:
            (i1, i2) = index
        except TypeError:
            raise IndexError('Block indexing requires exactly two indexes')

        if i1 < 0:
            i1 += self.len1
        if i2 < 0:
            i2 += self.len2

        self._check_indexes(i1, i2)
        return (i1, i2)

    def set_value(self, i1, i2, value):
        """Set the MergeRecord for integer indexes (i1, i2).

        i1 and i2 must be non-negative."""

        raise NotImplementedError()

    def __setitem__(self, index, value):
        """Return the MergeRecord for indexes (i1, i2).

        i1 and i2 must be integers, but they may be negative."""

        (i1, i2) = self._normalize_indexes(index)
        if i1 < 0:
            i1 += self.len1
        if i2 < 0:
            i2 += self.len2
        self.set_value(i1, i2, value)

    def get_value(self, i1, i2):
        """Return the MergeRecord for integer indexes (i1, i2).

        i1 and i2 must be non-negative."""

        raise NotImplementedError()

    def __getitem__(self, index):
        """Return the MergeRecord at (i1, i2) (requires two indexes).

        If i1 and i2 are integers but the merge is unknown, return
        None.  If either index is a slice, return a SubBlock."""

        try:
            (i1, i2) = index
        except TypeError:
            raise IndexError('Block indexing requires exactly two indexes')
        if isinstance(i1, slice) or isinstance(i2, slice):
            return SubBlock(self, i1, i2)
        else:
            return self.get_value(*self._normalize_indexes((i1, i2)))

    def __contains__(self, index):
        return self[index].is_known()

    def is_mergeable(self, i1, i2):
        """Determine whether (i1,i2) can be merged automatically.

        If we already have a merge record for (i1,i2), return True.
        Otherwise, attempt a merge (discarding the result)."""

        (i1, i2) = self._normalize_indexes((i1, i2))
        if (i1, i2) in self:
            return True
        else:
            try:
                automerge(self[i1, 0].sha1, self[0, i2].sha1)
                return True
            except AutomaticMergeFailed:
                return False

    def auto_outline(self):
        """Complete the outline of this Block.

        raise UnexpectedMergeFailure if automerging fails."""

        # Check that all of the merges go through before recording any
        # of them permanently.
        merges = []

        def do_merge(i1, commit1, i2, commit2):
            if (i1, i2) in self:
                return self[i1,i2].sha1
            try:
                merge = automerge(commit1, commit2)
            except AutomaticMergeFailed, e:
                raise UnexpectedMergeFailure(str(e), i1, i2)
            merges.append((i1, i2, merge))
            return merge

        i2 = self.len2 - 1
        left = self[0, i2].sha1
        for i1 in range(1, self.len1 - 1):
            left = do_merge(i1, self[i1,0].sha1, i2, left)

        i1 = self.len1 - 1
        above = self[i1, 0].sha1
        for i2 in range(1, self.len2 - 1):
            above = do_merge(i1, above, i2, self[0,i2].sha1)

        i1, i2 = self.len1 - 1, self.len2 - 1
        do_merge(i1, above, i2, left)

        # Success!  Now we can record the results:
        for (i1, i2, merge) in merges:
            self[i1, i2].record_merge(merge, MergeRecord.NEW_AUTO)

    def auto_outline_frontier(self, merge_frontier=None):
        if merge_frontier is None:
            merge_frontier = MergeFrontier.compute_by_bisection(self)

        if not merge_frontier:
            # Nothing to do.
            return

        # Determine which block has the largest area:
        def area(block):
            return (block.len1 - 1) * (block.len2 - 1)

        best_block = None
        best_area = 0

        for block in merge_frontier:
            a = area(block)
            if a > best_area:
                best_block = block
                best_area = a

        try:
            best_block.auto_outline()
        except UnexpectedMergeFailure, e:
            # One of the merges that we expected to succeed in
            # fact failed.
            i1, i2 = e.i1, e.i1
            merge_frontier.remove_failure(e.i1, e.i2)
            self.auto_outline_frontier(merge_frontier)
        else:
            f1, f2 = merge_frontier.partition(best_block)
            if f1:
                f1.block.auto_outline_frontier(f1)
            if f2:
                f2.block.auto_outline_frontier(f2)

    def _write(self, f, manual='*', auto='+', unknown='?', sep='', linesep='\n'):
        for i2 in range(self.len2):
            for i1 in range(self.len1):
                if i1 != 0:
                    f.write(sep)
                if (i1,i2) in self:
                    if self.get_value(i1, i2).flags & MergeRecord.MANUAL:
                        f.write(manual)
                    else:
                        f.write(auto)
                else:
                    f.write(unknown)
            f.write(linesep)

    def write(self, f):
        self._write(f)

    def writeppm(self, f):
        f.write('P3\n')
        f.write('%d %d 255\n' % (self.n1, self.n2,))
        self._write(
            f,
            manual='0 255 0',
            auto='0 127 0',
            unknown='127 127 0',
            sep='  ',
            )


class SubBlock(Block):
    @staticmethod
    def _convert_to_slice(i, len):
        """Return (start, len) for the specified index.

        i may be an integer or a slice with step equal to 1."""

        if isinstance(i, int):
            if i < 0:
                i += len
            i = slice(i, i + 1)
        elif isinstance(i, slice):
            if i.step is not None and i.step != 1:
                raise ValueError('Index has a non-zero step size')
        else:
            raise ValueError('Index cannot be converted to a slice')

        (start, stop, step) = i.indices(len)
        return (start, stop - start)

    def __init__(self, block, slice1, slice2):
        (start1, len1) = self._convert_to_slice(slice1, block.len1)
        (start2, len2) = self._convert_to_slice(slice2, block.len2)
        Block.__init__(self, len1, len2)
        if isinstance(block, SubBlock):
            # Peel away one level of indirection:
            self._block = block._block
            self._start1 = start1 + block._start1
            self._start2 = start2 + block._start2
        else:
            self._block = block
            self._start1 = start1
            self._start2 = start2

    def set_value(self, i1, i2, sha1, flags):
        self._check_indexes(i1, i2)
        self._block.set_value(i1 + self._start1, i2 + self._start2, sha1, flags)

    def get_value(self, i1, i2):
        self._check_indexes(i1, i2)
        return self._block.get_value(i1 + self._start1, i2 + self._start2)


class MergeState(Block):
    SOURCE_TABLE = {
        'auto' : MergeRecord.SAVED_AUTO,
        'manual' : MergeRecord.SAVED_MANUAL,
        }

    MERGE_STATE_RE = re.compile(
        r"""
        ^
        refs\/imerge\/
        (?P<name>[^\/]+)
        \/state
        $
        """,
        re.VERBOSE,
        )

    @staticmethod
    def iter_existing_names():
        """Iterate over the names of existing MergeStates in this repo."""

        for line in check_output(['git', 'for-each-ref', 'refs/imerge',]).splitlines():
            (sha1, type, refname) = line.split()
            if type == 'blob':
                m = MergeState.MERGE_STATE_RE.match(refname)
                if m:
                    yield m.group('name')

    @staticmethod
    def set_default_name(name):
        """Set the default merge to the specified one.

        name can be None to cause the default to be cleared."""

        if name is None:
            try:
                check_call(['git', 'config', '--unset', 'imerge.default'])
            except CalledProcessError, e:
                if e.returncode == 5:
                    # Value was not set
                    pass
                else:
                    raise
        else:
            check_call(['git', 'config', 'imerge.default', name])

    @staticmethod
    def get_default_name():
        """Get the name of the default merge, or None if none is currently set."""

        try:
            return check_output(['git', 'config', 'imerge.default']).rstrip()
        except CalledProcessError:
            return None

    @staticmethod
    def start(name, goal, tip1, tip2):
        """Create and return a new MergeState object."""

        if '/' in name:
            raise Failure('Name %r must not include a slash character!' % (name,))

        try:
            call_silently(
                ['git', 'check-ref-format', 'refs/imerge/%s' % (name,)]
                )
        except CalledProcessError:
            raise Failure('Name %r is not a valid refname component!' % (name,))

        if check_output(['git', 'for-each-ref', 'refs/imerge/%s' % (name,)]):
            raise Failure('Name %r is already in use!' % (name,))

        commits1 = rev_list('--first-parent', '%s..%s' % (tip2, tip1))
        commits1.reverse()
        if not commits1:
            raise Failure(
                'There are no commits on %r that are not already in %r' % (tip1, tip2)
                )
        commits2 = rev_list('--first-parent', '%s..%s' % (tip1, tip2))
        commits2.reverse()
        if not commits2:
            raise Failure(
                'There are no commits on %r that are not already in %r' % (tip2, tip1)
                )

        merge = MergeState(name, goal, commits1, commits2, MergeRecord.NEW_MANUAL)
        merge.save()
        return merge

    @staticmethod
    def read(name):
        merge_ref_re = re.compile(
            r"""
            ^
            refs\/imerge\/
            """ + re.escape(name) + r"""
            \/(?P<source>auto|manual)\/
            (?P<i1>0|[1-9][0-9]*)
            \-
            (?P<i2>0|[1-9][0-9]*)
            $
            """,
            re.VERBOSE,
            )

        state_ref_re = re.compile(
            r"""
            ^
            refs\/imerge\/
            """ + re.escape(name) + r"""
            \/state
            $
            """,
            re.VERBOSE,
            )

        state_string = None

        # A map {(i1, i2) : (sha1, source)}:
        merges = {}

        # refnames that were found but not understood:
        unexpected = []

        for line in check_output([
                'git', 'for-each-ref', 'refs/imerge/%s' % (name,)
                ]).splitlines():
            (sha1, type, refname) = line.split()
            m = merge_ref_re.match(refname)
            if m:
                if type != 'commit':
                    raise Failure('Reference %r is not a commit!' % (refname,))
                i1, i2 = int(m.group('i1')), int(m.group('i2'))
                source = MergeState.SOURCE_TABLE[m.group('source')]
                merges[i1, i2] = (sha1, source)
                continue

            m = state_ref_re.match(refname)
            if m:
                if type != 'blob':
                    raise Failure('Reference %r is not a blob!' % (refname,))
                state_string = check_output(['git', 'cat-file', 'blob', sha1])
                continue

            unexpected.append(refname)

        if state_string is None:
            raise Failure(
                'No state found; it should have been a blob reference at '
                '"refs/imerge/%s/state' % (name,)
                )

        state = json.loads(state_string)

        version = map(int, state['version'].split('.'))
        if version[0] != STATE_VERSION[0] or version > STATE_VERSION:
            raise Failure('Version of state is not compatible with this script version.')

        goal = state['goal']
        if goal not in ALLOWED_GOALS:
            raise Failure('Goal %r, read from state, is not recognized.' % (goal,))

        if unexpected:
            raise Failure(
                'Unexpected reference(s) found in "refs/imerge/%s" namespace:\n    %s\n'
                % (name, '\n    '.join(unexpected),)
                )

        # Find commits1 and commits2:
        commits1 = []
        for i1 in itertools.count(1):
            try:
                (sha1, source) = merges.pop((i1, 0))
                if source != MergeRecord.SAVED_MANUAL:
                    raise Failure('Merge (%d,0) should be manual!' % (i1,))
                commits1.append(sha1)
            except KeyError:
                break

        commits2 = []
        for i2 in itertools.count(1):
            try:
                (sha1, source) = merges.pop((0, i2))
                if source != MergeRecord.SAVED_MANUAL:
                    raise Failure('Merge (0,%d) should be manual!' % (i2,))
                commits2.append(sha1)
            except KeyError:
                break

        state = MergeState(name, goal, commits1, commits2, MergeRecord.SAVED_MANUAL)

        # Now write the rest of the merges to state:
        for ((i1, i2), (sha1, source)) in merges.iteritems():
            if i1 == 0 and i2 >= state.len2:
                raise Failure('Merge (0,%d) is missing!' % (state.len2,))
            if i1 >= state.len1 and i2 == 0:
                raise Failure('Merge (%d,0) is missing!' % (state.len1,))
            if i1 >= state.len1 or i2 >= state.len2:
                raise Failure(
                    'Merge (%d,%d) is out of range [0:%d,0:%d]'
                    % (i1, i2, state.len1, state.len2)
                    )
            state[i1, i2].record_merge(sha1, source)

        return state

    @staticmethod
    def remove(name):
        # If this merge is the default, unset the default:
        if MergeState.get_default_name() == name:
            MergeState.set_default_name(None)

        # Remove any references associated with this merge:
        for line in check_output([
                'git', 'for-each-ref', 'refs/imerge/%s' % (name,)
                ]).splitlines():
            (sha1, type, refname) = line.split()
            try:
                check_call([
                        'git', 'update-ref',
                        '-m', 'imerge: remove merge %r' % (name,),
                        '-d', refname,
                        ])
            except CalledProcessError, e:
                sys.stderr.write(
                    'Warning: error removing reference %r: %s' % (refname, e)
                    )

    def __init__(self, name, goal, commits1, commits2, source):
        Block.__init__(self, len(commits1) + 1, len(commits2) + 1)
        self.name = name
        self.goal = goal

        # A simulated 2D array.  Values are None or MergeRecord instances.
        self._data = [[None] * self.len2 for i1 in range(self.len1)]

        for (i1, commit) in enumerate(commits1, 1):
            self.get_value(i1, 0).record_merge(commit, source)
        for (i2, commit) in enumerate(commits2, 1):
            self.get_value(0, i2).record_merge(commit, source)

    def set_value(self, i1, i2, value):
        self._data[i1][i2] = value

    def get_value(self, i1, i2):
        value = self._data[i1][i2]
        # Missing values spring to life on first access:
        if value is None:
            value = MergeRecord()
            self._data[i1][i2] = value
        return value

    def __contains__(self, index):
        # Avoid creating new MergeRecord objects here.
        (i1, i2) = self._normalize_indexes(index)
        value = self._data[i1][i2]
        return (value is not None) and value.is_known()

    def save(self):
        """Write the current MergeState to the repository."""

        for i2 in range(0, self.len2):
            for i1 in range(0, self.len1):
                if (i1, i2) in self:
                    self[i1,i2].save(self.name, i1, i2)

        state = dict(
            version='.'.join(map(str, STATE_VERSION)),
            goal=self.goal,
            )
        state_string = json.dumps(state, sort_keys=True, indent=4)

        cmd = ['git', 'hash-object', '-t', 'blob', '-w', '--stdin']
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        (out, err) = p.communicate(state_string)
        retcode = p.poll()
        if retcode:
            raise CalledProcessError(retcode, cmd, output=out)
        sha1 = out.strip()
        check_call([
                'git', 'update-ref',
                '-m', 'imerge %r: Record state' % (self.name,),
                'refs/imerge/%s/state' % (self.name,),
                sha1,
                ])


@Failure.wrap
def main(args):
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        )
    subparsers = parser.add_subparsers(dest='subcommand', help='sub-command')

    parser_start = subparsers.add_parser(
        'start',
        help='start an incremental merge',
        )
    parser_start.add_argument(
        '--name', action='store', default='merge',
        help='name to use for this incremental merge',
        )
    parser_start.add_argument(
        '--goal',
        action='store', default=DEFAULT_GOAL,
        choices=ALLOWED_GOALS,
        help='the goal of the incremental merge',
        )
    #parser_start.add_argument(
    #    '--conflicts', ...
    #    action='store', default='pairwise',
    #    choices=['pairwise', 'fewest'],
    #    help='what sort of conflicts will be presented to the user',
    #    )
    parser_start.add_argument(
        '--first-parent', action='store_true', default=None,
        help=(
            'handle only the first parent commits '
            '(this option is currently required)'
            ),
        )
    parser_start.add_argument(
        'branch', action='store',
        help='the tip of the branch to be merged into HEAD',
        )

    parser_remove = subparsers.add_parser(
        'remove',
        help='irrevocably remove an incremental merge',
        )
    parser_remove.add_argument(
        '--name', action='store', default=None,
        help='name to use for this incremental merge',
        )

    parser_list = subparsers.add_parser(
        'list',
        help='list names of in-progress merges',
        )

    parser_autofill = subparsers.add_parser(
        'autofill',
        help='autofill non-conflicting merges',
        )
    parser_autofill.add_argument(
        '--name', action='store', default=None,
        help='name of merge to autofill',
        )

    parser_diagram = subparsers.add_parser(
        'diagram',
        help='display diagram of current state of merge',
        )
    parser_diagram.add_argument(
        '--name', action='store', default=None,
        help='name of merge to diagram',
        )

    parser_reparent = subparsers.add_parser(
        'reparent',
        help='change the parents of the HEAD commit',
        )
    parser_reparent.add_argument(
        'parents', nargs='*', help='[PARENT...]',
        )

    options = parser.parse_args(args)

    require_clean_work_tree('proceed')

    if options.subcommand == 'list':
        default_merge = MergeState.get_default_name()
        for name in MergeState.iter_existing_names():
            if name == default_merge:
                sys.stdout.write('* %s\n' % (name,))
            else:
                sys.stdout.write('  %s\n' % (name,))
    elif options.subcommand == 'start':
        if not options.first_parent:
            parser.error(
                'The --first-parent option is currently required for the "start" command'
                )
        MergeState.start(options.name, options.goal, 'HEAD', options.branch)
        MergeState.set_default_name(options.name)
    elif options.subcommand == 'remove':
        if options.name is None:
            parser.error('The "remove" command requires an option --name=NAME')
        state = MergeState.remove(options.name)
    elif options.subcommand == 'autofill':
        if not options.name:
            options.name = MergeState.get_default_name()
            if not options.name:
                raise Failure('Please specify the name of the merge to autofill')
        merge_state = MergeState.read(options.name)
        with TemporaryHead():
            merge_state.auto_outline_frontier()
        merge_state.save()
    elif options.subcommand == 'diagram':
        if not options.name:
            options.name = MergeState.get_default_name()
            if not options.name:
                raise Failure('Please specify the name of the merge to diagram')
        merge_state = MergeState.read(options.name)
        merge_state.write(sys.stdout)
    elif options.subcommand == 'reparent':
        try:
            commit_sha1 = get_commit_sha1('HEAD')
        except ValueError:
            sys.exit('HEAD is not a valid commit')

        try:
            parent_sha1s = map(get_commit_sha1, options.parents)
        except ValueError, e:
            sys.exit(e.message)

        sys.stdout.write('%s\n' % (reparent(commit_sha1, parent_sha1s),))
    else:
        parser.error('Unrecognized subcommand')


main(sys.argv[1:])

